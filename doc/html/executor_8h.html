<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>monad core runloop: include/monad/async/executor.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">monad core runloop
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li><li class="navelem"><a class="el" href="dir_e06f317e197b11f262881a927ceb2703.html">monad</a></li><li class="navelem"><a class="el" href="dir_be5960affa6c37e6690634143faeeb04.html">async</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">executor.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="config_8h_source.html">config.h</a>&quot;</code><br />
<code>#include &lt;liburing.h&gt;</code><br />
<code>#include &lt;stdatomic.h&gt;</code><br />
<code>#include &quot;<a class="el" href="async_2task_8h_source.html">task.h</a>&quot;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for executor.h:</div>
<div class="dyncontent">
<div class="center"><img src="executor_8h__incl.png" border="0" usemap="#ainclude_2monad_2async_2executor_8h" alt=""/></div>
<map name="ainclude_2monad_2async_2executor_8h" id="ainclude_2monad_2async_2executor_8h">
<area shape="rect" title=" " alt="" coords="69,5,214,47"/>
<area shape="rect" href="config_8h.html" title=" " alt="" coords="23,244,91,271"/>
<area shape="rect" title=" " alt="" coords="271,95,345,121"/>
<area shape="rect" title=" " alt="" coords="116,244,207,271"/>
<area shape="rect" href="async_2task_8h.html" title=" " alt="" coords="188,95,247,121"/>
<area shape="rect" href="boost__result_8h.html" title=" " alt="" coords="5,319,109,345"/>
<area shape="rect" title=" " alt="" coords="25,393,90,420"/>
<area shape="rect" href="context__switcher_8h.html" title=" " alt="" coords="196,169,327,196"/>
<area shape="rect" title=" " alt="" coords="257,244,332,271"/>
<area shape="rect" title=" " alt="" coords="369,244,433,271"/>
</map>
</div>
</div><div class="textblock"><div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dyncontent">
<div class="center"><img src="executor_8h__dep__incl.png" border="0" usemap="#ainclude_2monad_2async_2executor_8hdep" alt=""/></div>
<map name="ainclude_2monad_2async_2executor_8hdep" id="ainclude_2monad_2async_2executor_8hdep">
<area shape="rect" title=" " alt="" coords="91,5,236,47"/>
<area shape="rect" href="async_2all_8h.html" title=" " alt="" coords="5,184,151,225"/>
<area shape="rect" href="cpp__helpers_8hpp.html" title=" " alt="" coords="188,184,333,225"/>
<area shape="rect" href="work__dispatcher_8h.html" title=" " alt="" coords="91,95,236,136"/>
</map>
</div>
</div>
<p><a href="executor_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmonad__async__executor__head.html">monad_async_executor_head</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The public attributes of an executor.  <a href="structmonad__async__executor__head.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmonad__async__executor__attr.html">monad_async_executor_attr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes by which to construct an executor.  <a href="structmonad__async__executor__attr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmonad__async__executor__registered__io__buffer.html">monad_async_executor_registered_io_buffer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A registered i/o buffer.  <a href="structmonad__async__executor__registered__io__buffer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a3aba786d65f9c828e78bdd33031752b6"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structmonad__async__executor__head.html">monad_async_executor_head</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="executor_8h.html#a3aba786d65f9c828e78bdd33031752b6">monad_async_executor</a></td></tr>
<tr class="memdesc:a3aba786d65f9c828e78bdd33031752b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The public attributes of an executor.  <a href="executor_8h.html#a3aba786d65f9c828e78bdd33031752b6">More...</a><br /></td></tr>
<tr class="separator:a3aba786d65f9c828e78bdd33031752b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a347b8613887ce521a3add18cb0e359f3"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structmonad__async__executor__registered__io__buffer.html">monad_async_executor_registered_io_buffer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="executor_8h.html#a347b8613887ce521a3add18cb0e359f3">monad_async_executor_registered_io_buffer</a></td></tr>
<tr class="memdesc:a347b8613887ce521a3add18cb0e359f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">A registered i/o buffer.  <a href="executor_8h.html#a347b8613887ce521a3add18cb0e359f3">More...</a><br /></td></tr>
<tr class="separator:a347b8613887ce521a3add18cb0e359f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aaca421852c2a298c56d14197bcf068a3"><td class="memItemLeft" align="right" valign="top">monad_async_result&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="executor_8h.html#aaca421852c2a298c56d14197bcf068a3">monad_async_executor_create</a> (<a class="el" href="executor_8h.html#a3aba786d65f9c828e78bdd33031752b6">monad_async_executor</a> *ex, struct <a class="el" href="structmonad__async__executor__attr.html">monad_async_executor_attr</a> *attr)</td></tr>
<tr class="memdesc:aaca421852c2a298c56d14197bcf068a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">EXPENSIVE Creates an executor instance. You must create it on the kernel thread where it will be used.  <a href="executor_8h.html#aaca421852c2a298c56d14197bcf068a3">More...</a><br /></td></tr>
<tr class="separator:aaca421852c2a298c56d14197bcf068a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5085fafc69fb5da32272111d2449876"><td class="memItemLeft" align="right" valign="top">monad_async_result&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="executor_8h.html#ad5085fafc69fb5da32272111d2449876">monad_async_executor_destroy</a> (<a class="el" href="executor_8h.html#a3aba786d65f9c828e78bdd33031752b6">monad_async_executor</a> ex)</td></tr>
<tr class="memdesc:ad5085fafc69fb5da32272111d2449876"><td class="mdescLeft">&#160;</td><td class="mdescRight">EXPENSIVE Destroys an executor instance.  <a href="executor_8h.html#ad5085fafc69fb5da32272111d2449876">More...</a><br /></td></tr>
<tr class="separator:ad5085fafc69fb5da32272111d2449876"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa167bb2f98d160c08fd028073a2df447"><td class="memItemLeft" align="right" valign="top">monad_async_result&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="executor_8h.html#aa167bb2f98d160c08fd028073a2df447">monad_async_executor_run</a> (<a class="el" href="executor_8h.html#a3aba786d65f9c828e78bdd33031752b6">monad_async_executor</a> ex, size_t max_items, struct timespec *timeout)</td></tr>
<tr class="memdesc:aa167bb2f98d160c08fd028073a2df447"><td class="mdescLeft">&#160;</td><td class="mdescRight">Processes no more than <code>max_items</code> work items, returning the number of items processed. A null <code>timeout</code> means wait forever, and a zero timeout will poll without blocking.  <a href="executor_8h.html#aa167bb2f98d160c08fd028073a2df447">More...</a><br /></td></tr>
<tr class="separator:aa167bb2f98d160c08fd028073a2df447"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e97a25b5a5b75dd3fe5297ec269e7f4"><td class="memItemLeft" align="right" valign="top">monad_async_result&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="executor_8h.html#a8e97a25b5a5b75dd3fe5297ec269e7f4">monad_async_executor_wake</a> (<a class="el" href="executor_8h.html#a3aba786d65f9c828e78bdd33031752b6">monad_async_executor</a> ex, monad_async_result const *cause_run_to_return)</td></tr>
<tr class="memdesc:a8e97a25b5a5b75dd3fe5297ec269e7f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">THREADSAFE Causes a sleeping executor to wake. Can be called from any kernel thread. <code>cause_run_to_return</code> causes <code><a class="el" href="executor_8h.html#aa167bb2f98d160c08fd028073a2df447" title="Processes no more than max_items work items, returning the number of items processed....">monad_async_executor_run()</a></code> to return the result given, otherwise the internal sleep wakes, executor state is examined for new work and the sleep reestablished.  <a href="executor_8h.html#a8e97a25b5a5b75dd3fe5297ec269e7f4">More...</a><br /></td></tr>
<tr class="separator:a8e97a25b5a5b75dd3fe5297ec269e7f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafe107b73e4560dac6ecf633d85a89d0"><td class="memItemLeft" align="right" valign="top">monad_async_result&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="executor_8h.html#aafe107b73e4560dac6ecf633d85a89d0">monad_async_executor_claim_registered_io_buffer</a> (<a class="el" href="structmonad__async__executor__registered__io__buffer.html">monad_async_executor_registered_io_buffer</a> *buffer, <a class="el" href="executor_8h.html#a3aba786d65f9c828e78bdd33031752b6">monad_async_executor</a> ex, size_t bytes_requested, bool is_for_write)</td></tr>
<tr class="memdesc:aafe107b73e4560dac6ecf633d85a89d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Claim an unused registered buffer, if there is one.  <a href="executor_8h.html#aafe107b73e4560dac6ecf633d85a89d0">More...</a><br /></td></tr>
<tr class="separator:aafe107b73e4560dac6ecf633d85a89d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab00e50ea8ff3e5015d4e5d65e9ddb0ba"><td class="memItemLeft" align="right" valign="top">monad_async_result&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="executor_8h.html#ab00e50ea8ff3e5015d4e5d65e9ddb0ba">monad_async_executor_release_registered_io_buffer</a> (<a class="el" href="executor_8h.html#a3aba786d65f9c828e78bdd33031752b6">monad_async_executor</a> ex, int buffer_index)</td></tr>
<tr class="memdesc:ab00e50ea8ff3e5015d4e5d65e9ddb0ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release a previously claimed registered buffer.  <a href="executor_8h.html#ab00e50ea8ff3e5015d4e5d65e9ddb0ba">More...</a><br /></td></tr>
<tr class="separator:ab00e50ea8ff3e5015d4e5d65e9ddb0ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a3aba786d65f9c828e78bdd33031752b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3aba786d65f9c828e78bdd33031752b6">&#9670;&nbsp;</a></span>monad_async_executor</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structmonad__async__executor__head.html">monad_async_executor_head</a> * <a class="el" href="executor_8h.html#a3aba786d65f9c828e78bdd33031752b6">monad_async_executor</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The public attributes of an executor. </p>

</div>
</div>
<a id="a347b8613887ce521a3add18cb0e359f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a347b8613887ce521a3add18cb0e359f3">&#9670;&nbsp;</a></span>monad_async_executor_registered_io_buffer</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structmonad__async__executor__registered__io__buffer.html">monad_async_executor_registered_io_buffer</a> <a class="el" href="structmonad__async__executor__registered__io__buffer.html">monad_async_executor_registered_io_buffer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A registered i/o buffer. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="aafe107b73e4560dac6ecf633d85a89d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafe107b73e4560dac6ecf633d85a89d0">&#9670;&nbsp;</a></span>monad_async_executor_claim_registered_io_buffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">monad_async_result monad_async_executor_claim_registered_io_buffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmonad__async__executor__registered__io__buffer.html">monad_async_executor_registered_io_buffer</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="executor_8h.html#a3aba786d65f9c828e78bdd33031752b6">monad_async_executor</a>&#160;</td>
          <td class="paramname"><em>ex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bytes_requested</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_for_write</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Claim an unused registered buffer, if there is one. </p>
<p>There are two sizes of registered i/o buffer, small and large which are the page size of the host platform (e.g. 4Kb and 2Mb if on Intel x64). Through being a single page size, DMA using registered i/o buffers has the lowest possible overhead. </p>

</div>
</div>
<a id="aaca421852c2a298c56d14197bcf068a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaca421852c2a298c56d14197bcf068a3">&#9670;&nbsp;</a></span>monad_async_executor_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">monad_async_result monad_async_executor_create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="executor_8h.html#a3aba786d65f9c828e78bdd33031752b6">monad_async_executor</a> *&#160;</td>
          <td class="paramname"><em>ex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structmonad__async__executor__attr.html">monad_async_executor_attr</a> *&#160;</td>
          <td class="paramname"><em>attr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>EXPENSIVE Creates an executor instance. You must create it on the kernel thread where it will be used. </p>
<p>Generally, one also needs to create context switcher instances for each executor instance. This is because the context switcher needs to store how to resume the executor when a task's execution suspends. </p>

</div>
</div>
<a id="ad5085fafc69fb5da32272111d2449876"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5085fafc69fb5da32272111d2449876">&#9670;&nbsp;</a></span>monad_async_executor_destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">monad_async_result monad_async_executor_destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="executor_8h.html#a3aba786d65f9c828e78bdd33031752b6">monad_async_executor</a>&#160;</td>
          <td class="paramname"><em>ex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>EXPENSIVE Destroys an executor instance. </p>

</div>
</div>
<a id="ab00e50ea8ff3e5015d4e5d65e9ddb0ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab00e50ea8ff3e5015d4e5d65e9ddb0ba">&#9670;&nbsp;</a></span>monad_async_executor_release_registered_io_buffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">monad_async_result monad_async_executor_release_registered_io_buffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="executor_8h.html#a3aba786d65f9c828e78bdd33031752b6">monad_async_executor</a>&#160;</td>
          <td class="paramname"><em>ex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>buffer_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Release a previously claimed registered buffer. </p>

</div>
</div>
<a id="aa167bb2f98d160c08fd028073a2df447"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa167bb2f98d160c08fd028073a2df447">&#9670;&nbsp;</a></span>monad_async_executor_run()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">monad_async_result monad_async_executor_run </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="executor_8h.html#a3aba786d65f9c828e78bdd33031752b6">monad_async_executor</a>&#160;</td>
          <td class="paramname"><em>ex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_items</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct timespec *&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Processes no more than <code>max_items</code> work items, returning the number of items processed. A null <code>timeout</code> means wait forever, and a zero timeout will poll without blocking. </p>
<p>Note that this function is particularly prone to early return i.e. partly or entirely ignoring timeout. Causes can include being woken externally by <code><a class="el" href="executor_8h.html#a8e97a25b5a5b75dd3fe5297ec269e7f4" title="THREADSAFE Causes a sleeping executor to wake. Can be called from any kernel thread....">monad_async_executor_wake()</a></code>, there being write i/o pending (as then two rings need to be checked), and the usual spurious early timeouts from Linux. If you do complex processing around calling this function, it may be wise to only do that processing if the value returned is not zero. </p>

</div>
</div>
<a id="a8e97a25b5a5b75dd3fe5297ec269e7f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e97a25b5a5b75dd3fe5297ec269e7f4">&#9670;&nbsp;</a></span>monad_async_executor_wake()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">monad_async_result monad_async_executor_wake </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="executor_8h.html#a3aba786d65f9c828e78bdd33031752b6">monad_async_executor</a>&#160;</td>
          <td class="paramname"><em>ex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">monad_async_result const *&#160;</td>
          <td class="paramname"><em>cause_run_to_return</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>THREADSAFE Causes a sleeping executor to wake. Can be called from any kernel thread. <code>cause_run_to_return</code> causes <code><a class="el" href="executor_8h.html#aa167bb2f98d160c08fd028073a2df447" title="Processes no more than max_items work items, returning the number of items processed....">monad_async_executor_run()</a></code> to return the result given, otherwise the internal sleep wakes, executor state is examined for new work and the sleep reestablished. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
