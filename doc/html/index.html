<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>monad core runloop: Proposed replacement executor</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">monad core runloop
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Proposed replacement executor </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md_Readme"></a> <a href="https://github.com/monad-crypto/fiber-sandbox/actions/workflows/ci.yml"><img src="https://github.com/monad-crypto/fiber-sandbox/actions/workflows/ci.yml/badge.svg" alt="CI" style="pointer-events: none;" class="inline"/></a></p>
<h1><a class="anchor" id="autotoc_md1"></a>
Features:</h1>
<ol type="1">
<li>100% C throughout, easing FFI into Rust and other languages.</li>
<li>100% priority based, with three levels of individual priority for CPU and I/O.</li>
<li>100% deterministic in the hot path so long as new work is launched from the same thread as the executor: no thread synchronisation, no malloc, no unbounded loops. 100% wait free, unless waits are requested or work is posted from foreign kernel threads.</li>
<li>Tasks can be launched on executors running on non-local kernel threads, thus making implementing a priority-based kernel thread pool very straightforward.</li>
<li>Tasks have runtime pluggable context switching implementations, which allows zero overhead support for C++ or Rust coroutines.</li>
<li>Integrated ultra-lightweight CPU timestamp counter based time tracking throughout.</li>
<li>Async file i/o: open, close, read, write, sync range, durable sync.</li>
</ol>
<h1><a class="anchor" id="autotoc_md2"></a>
Benchmarks:</h1>
<h2><a class="anchor" id="autotoc_md3"></a>
Single execution:</h2>
<h3><a class="anchor" id="autotoc_md4"></a>
Launch new work on executor:</h3>
<ul>
<li>Time between launching a new task and it beginning execution: <b>100 ns</b>.</li>
<li>Time between a task beginning execution and it being wound up: <b>90 ns</b>.</li>
</ul>
<h3><a class="anchor" id="autotoc_md5"></a>
Launch new work on executor which suspends on an i/o, resumes and then exits:</h3>
<ul>
<li>Time between launching a new task and it beginning execution: <b>130 ns</b>.</li>
<li>Time between a task beginning execution and it initiating the i/o with io_uring, and then suspending awaiting the i/o completion: <b>120 ns</b>.</li>
<li>Time between i/o completing and task resumption: <b>50 ns</b>.</li>
<li>Time between task resumption and it being wound up: <b>120 ns</b>.</li>
</ul>
<h3><a class="anchor" id="autotoc_md6"></a>
Launch new work on next idle executor in a thread pool:</h3>
<ul>
<li>Loop initiating, executing and tearing down tasks from one kernel thread onto a pool of sixty-four executors each running on their own kernel thread: <b>861.84 ns/op</b>.</li>
</ul>
<h2><a class="anchor" id="autotoc_md7"></a>
Superscalar execution:</h2>
<ul>
<li>Loop initiating, executing and tearing down tasks on the same kernel thread: <b>39.6 ns</b>/op (4.8x, CPU is capable of 5x).</li>
<li>Loop suspend-resuming a task using an io_uring noop (i.e. minimum possible io_uring op overhead): <b>85.766 ns</b>/op (3.38x, io_uring cycle is not superscalar friendly).</li>
</ul>
<h1><a class="anchor" id="autotoc_md8"></a>
Examples of use:</h1>
<h2><a class="anchor" id="autotoc_md9"></a>
Execute a task on an executor</h2>
<div class="fragment"><div class="line">monad_async_result r;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create an executor</span></div>
<div class="line"><a class="code" href="structmonad__async__executor__head.html">monad_async_executor</a> ex;</div>
<div class="line"><span class="keyword">struct </span><a class="code" href="structmonad__async__executor__attr.html">monad_async_executor_attr</a> ex_attr;</div>
<div class="line">memset(&amp;ex_attr, 0, <span class="keyword">sizeof</span>(ex_attr));</div>
<div class="line">ex_attr.io_uring_ring.entries = 64;</div>
<div class="line">r = <a class="code" href="executor_8h.html#aaca421852c2a298c56d14197bcf068a3">monad_async_executor_create</a>(&amp;ex, &amp;ex_attr);  <span class="comment">// expensive</span></div>
<div class="line">CHECK_RESULT(r);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create a context switcher</span></div>
<div class="line"><span class="comment">// Each task can have its own context switcher, and the executor</span></div>
<div class="line"><span class="comment">// will suspend and resume that task with its context switcher</span></div>
<div class="line"><span class="comment">// You can have as many context switcher types per executor as</span></div>
<div class="line"><span class="comment">// you like. This is a setjmp/longjmp context switcher. There</span></div>
<div class="line"><span class="comment">// can be many others.</span></div>
<div class="line"><a class="code" href="structmonad__async__context__switcher__head.html">monad_async_context_switcher</a> switcher_sjlj;</div>
<div class="line">r = <a class="code" href="context__switcher_8h.html#a5ed59cb2cffbe9aee2ab5feb1c853ee4">monad_async_context_switcher_sjlj_create</a>(&amp;switcher_sjlj);</div>
<div class="line">CHECK_RESULT(r);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create a task. Creating these is expensive, but they can be</span></div>
<div class="line"><span class="comment">// reused very efficiently when they complete their assigned work.</span></div>
<div class="line"><a class="code" href="structmonad__async__task__head.html">monad_async_task</a> task;</div>
<div class="line"><span class="keyword">struct </span><a class="code" href="structmonad__async__task__attr.html">monad_async_task_attr</a> t_attr;</div>
<div class="line">memset(&amp;t_attr, 0, <span class="keyword">sizeof</span>(t_attr));</div>
<div class="line">r = <a class="code" href="async_2task_8h.html#af8bf268e625fba73a15cab8bcac30cc7">monad_async_task_create</a>(&amp;task, switcher_sjlj, &amp;t_attr);  <span class="comment">// expensive</span></div>
<div class="line">CHECK_RESULT(r);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Set what work this task will do and its priority</span></div>
<div class="line">task-&gt;<a class="code" href="structmonad__async__task__head.html#a83cd3f9f7e5c466e75f1dea3d39ba170">priority</a>.<a class="code" href="structmonad__async__task__head.html#a561e42ebaad4e8d603a091dd39f964e2">cpu</a> = <a class="code" href="config_8h.html#a72ee33b31033fefa7c636395298f3aeea077003903e156adc3b2440732b917ca0">monad_async_priority_high</a>;</div>
<div class="line">task-&gt;<a class="code" href="structmonad__async__task__head.html#a4f0bab336a6605be9bfc80f6b2b153a1">user_code</a> = myfunc;</div>
<div class="line">task-&gt;<a class="code" href="structmonad__async__task__head.html#a89b8a8266f3ca2bf34609617088ecf2d">user_ptr</a> = myptr;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// From now on cheap and deterministic in the hot path</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Schedule this task for execution. This is threadsafe, which</span></div>
<div class="line"><span class="comment">// lets you easily build thread pools of high performance executors</span></div>
<div class="line">r = <a class="code" href="async_2task_8h.html#a760fd7d7c1cb371c418410b524ccf122">monad_async_task_attach</a>(ex, task, <span class="keyword">nullptr</span>);</div>
<div class="line">CHECK_RESULT(r);</div>
<div class="line"> </div>
<div class="line">...</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Executor run loop</span></div>
<div class="line">r = <a class="code" href="executor_8h.html#aa167bb2f98d160c08fd028073a2df447">monad_async_executor_run</a>(ex,</div>
<div class="line">  1,       <span class="comment">// max items to complete this run</span></div>
<div class="line">  <span class="keyword">nullptr</span>  <span class="comment">// optional struct timespec timeout, can be {0, 0}</span></div>
<div class="line">);</div>
<div class="line">CHECK_RESULT(r);</div>
<div class="line"><span class="comment">// r.value is the number of items of work done, ETIME if it timed</span></div>
<div class="line"><span class="comment">// out and no work was done.</span></div>
<div class="line"> </div>
<div class="line">...</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Back to expensive operations. In C++ these can be easily wrapped</span></div>
<div class="line"><span class="comment">// into unique_ptrs (c.f. cpp_helpers.hpp)</span></div>
<div class="line">r = <a class="code" href="async_2task_8h.html#ac058560fdaab64de44d2d12458d74514">monad_async_task_destroy</a>(task);</div>
<div class="line">CHECK_RESULT(r);</div>
<div class="line">r = <a class="code" href="context__switcher_8h.html#a6ef1b07fd61f1b7446797767d0584acf">monad_async_context_switcher_destroy</a>(switcher_sjlj);</div>
<div class="line">CHECK_RESULT(r);</div>
<div class="line">r = <a class="code" href="executor_8h.html#ad5085fafc69fb5da32272111d2449876">monad_async_executor_destroy</a>(ex);</div>
<div class="line">CHECK_RESULT(r);</div>
<div class="ttc" id="aasync_2task_8h_html_a760fd7d7c1cb371c418410b524ccf122"><div class="ttname"><a href="async_2task_8h.html#a760fd7d7c1cb371c418410b524ccf122">monad_async_task_attach</a></div><div class="ttdeci">monad_async_result monad_async_task_attach(monad_async_executor executor, monad_async_task task, monad_async_context_switcher opt_reparent_switcher)</div><div class="ttdoc">THREADSAFE Attaches a task instance onto a given executor, which means it will launch the next time t...</div></div>
<div class="ttc" id="aasync_2task_8h_html_ac058560fdaab64de44d2d12458d74514"><div class="ttname"><a href="async_2task_8h.html#ac058560fdaab64de44d2d12458d74514">monad_async_task_destroy</a></div><div class="ttdeci">monad_async_result monad_async_task_destroy(monad_async_task task)</div><div class="ttdoc">EXPENSIVE Destroys a task instance. If the task is currently suspended, it will be cancelled first in...</div></div>
<div class="ttc" id="aasync_2task_8h_html_af8bf268e625fba73a15cab8bcac30cc7"><div class="ttname"><a href="async_2task_8h.html#af8bf268e625fba73a15cab8bcac30cc7">monad_async_task_create</a></div><div class="ttdeci">monad_async_result monad_async_task_create(monad_async_task *task, monad_async_context_switcher switcher, struct monad_async_task_attr *attr)</div><div class="ttdoc">EXPENSIVE Creates a task instance using the specified context switcher.</div></div>
<div class="ttc" id="aconfig_8h_html_a72ee33b31033fefa7c636395298f3aeea077003903e156adc3b2440732b917ca0"><div class="ttname"><a href="config_8h.html#a72ee33b31033fefa7c636395298f3aeea077003903e156adc3b2440732b917ca0">monad_async_priority_high</a></div><div class="ttdeci">@ monad_async_priority_high</div><div class="ttdef"><b>Definition:</b> config.h:98</div></div>
<div class="ttc" id="acontext__switcher_8h_html_a5ed59cb2cffbe9aee2ab5feb1c853ee4"><div class="ttname"><a href="context__switcher_8h.html#a5ed59cb2cffbe9aee2ab5feb1c853ee4">monad_async_context_switcher_sjlj_create</a></div><div class="ttdeci">monad_async_result monad_async_context_switcher_sjlj_create(monad_async_context_switcher *switcher)</div><div class="ttdoc">Creates a setjmp/longjmp based context switcher with each task getting its own stack.</div></div>
<div class="ttc" id="acontext__switcher_8h_html_a6ef1b07fd61f1b7446797767d0584acf"><div class="ttname"><a href="context__switcher_8h.html#a6ef1b07fd61f1b7446797767d0584acf">monad_async_context_switcher_destroy</a></div><div class="ttdeci">monad_async_result monad_async_context_switcher_destroy(monad_async_context_switcher switcher)</div><div class="ttdoc">Destroys any context switcher.</div><div class="ttdef"><b>Definition:</b> context_switcher.h:94</div></div>
<div class="ttc" id="aexecutor_8h_html_aa167bb2f98d160c08fd028073a2df447"><div class="ttname"><a href="executor_8h.html#aa167bb2f98d160c08fd028073a2df447">monad_async_executor_run</a></div><div class="ttdeci">monad_async_result monad_async_executor_run(monad_async_executor ex, size_t max_items, struct timespec *timeout)</div><div class="ttdoc">Processes no more than max_items work items, returning the number of items processed....</div></div>
<div class="ttc" id="aexecutor_8h_html_aaca421852c2a298c56d14197bcf068a3"><div class="ttname"><a href="executor_8h.html#aaca421852c2a298c56d14197bcf068a3">monad_async_executor_create</a></div><div class="ttdeci">monad_async_result monad_async_executor_create(monad_async_executor *ex, struct monad_async_executor_attr *attr)</div><div class="ttdoc">EXPENSIVE Creates an executor instance. You must create it on the kernel thread where it will be used...</div></div>
<div class="ttc" id="aexecutor_8h_html_ad5085fafc69fb5da32272111d2449876"><div class="ttname"><a href="executor_8h.html#ad5085fafc69fb5da32272111d2449876">monad_async_executor_destroy</a></div><div class="ttdeci">monad_async_result monad_async_executor_destroy(monad_async_executor ex)</div><div class="ttdoc">EXPENSIVE Destroys an executor instance.</div></div>
<div class="ttc" id="astructmonad__async__context__switcher__head_html"><div class="ttname"><a href="structmonad__async__context__switcher__head.html">monad_async_context_switcher_head</a></div><div class="ttdef"><b>Definition:</b> context_switcher.h:21</div></div>
<div class="ttc" id="astructmonad__async__executor__attr_html"><div class="ttname"><a href="structmonad__async__executor__attr.html">monad_async_executor_attr</a></div><div class="ttdoc">Attributes by which to construct an executor.</div><div class="ttdef"><b>Definition:</b> executor.h:66</div></div>
<div class="ttc" id="astructmonad__async__executor__head_html"><div class="ttname"><a href="structmonad__async__executor__head.html">monad_async_executor_head</a></div><div class="ttdoc">The public attributes of an executor.</div><div class="ttdef"><b>Definition:</b> executor.h:19</div></div>
<div class="ttc" id="astructmonad__async__task__attr_html"><div class="ttname"><a href="structmonad__async__task__attr.html">monad_async_task_attr</a></div><div class="ttdoc">Attributes by which to construct a task.</div><div class="ttdef"><b>Definition:</b> task.h:142</div></div>
<div class="ttc" id="astructmonad__async__task__head_html"><div class="ttname"><a href="structmonad__async__task__head.html">monad_async_task_head</a></div><div class="ttdoc">The public attributes of a task.</div><div class="ttdef"><b>Definition:</b> task.h:62</div></div>
<div class="ttc" id="astructmonad__async__task__head_html_a4f0bab336a6605be9bfc80f6b2b153a1"><div class="ttname"><a href="structmonad__async__task__head.html#a4f0bab336a6605be9bfc80f6b2b153a1">monad_async_task_head::user_code</a></div><div class="ttdeci">monad_async_result(* user_code)(struct monad_async_task_head *)</div><div class="ttdef"><b>Definition:</b> task.h:64</div></div>
<div class="ttc" id="astructmonad__async__task__head_html_a561e42ebaad4e8d603a091dd39f964e2"><div class="ttname"><a href="structmonad__async__task__head.html#a561e42ebaad4e8d603a091dd39f964e2">monad_async_task_head::cpu</a></div><div class="ttdeci">monad_async_priority cpu</div><div class="ttdef"><b>Definition:</b> task.h:70</div></div>
<div class="ttc" id="astructmonad__async__task__head_html_a83cd3f9f7e5c466e75f1dea3d39ba170"><div class="ttname"><a href="structmonad__async__task__head.html#a83cd3f9f7e5c466e75f1dea3d39ba170">monad_async_task_head::priority</a></div><div class="ttdeci">struct monad_async_task_head::@3 priority</div></div>
<div class="ttc" id="astructmonad__async__task__head_html_a89b8a8266f3ca2bf34609617088ecf2d"><div class="ttname"><a href="structmonad__async__task__head.html#a89b8a8266f3ca2bf34609617088ecf2d">monad_async_task_head::user_ptr</a></div><div class="ttdeci">void * user_ptr</div><div class="ttdef"><b>Definition:</b> task.h:65</div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md10"></a>
Task</h2>
<p>The task object can be reused for different work after the work completes.</p>
<div class="fragment"><div class="line"><span class="keyword">static</span> monad_async_result myfunc(<a class="code" href="structmonad__async__task__head.html">monad_async_task</a> task)</div>
<div class="line">{</div>
<div class="line">  <span class="comment">/* do stuff */</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Suspend and resume after one second</span></div>
<div class="line">  r = <a class="code" href="async_2task_8h.html#afca68102c0535bb620b468936f884d2a">monad_async_task_suspend_for_duration</a>(<span class="keyword">nullptr</span>, task, 1000000000ULL);</div>
<div class="line">  CHECK_RESULT(r);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// You could also read from a socket, write to a file, do any</span></div>
<div class="line">  <span class="comment">// other operation which io_uring supports. They all appear as</span></div>
<div class="line">  <span class="comment">// suspend and resume. If the context switcher for this task</span></div>
<div class="line">  <span class="comment">// were a C++ coroutine switcher, this function could be a C++</span></div>
<div class="line">  <span class="comment">// coroutine and it would work seamlessly and with no loss of</span></div>
<div class="line">  <span class="comment">// efficiency.</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">// All done, return success</span></div>
<div class="line">  <span class="keywordflow">return</span> <a class="code" href="config_8h.html#ac4ae990e585e8fcb3923df7511c68ad9">monad_async_make_success</a>(0);</div>
<div class="line">}</div>
<div class="ttc" id="aasync_2task_8h_html_afca68102c0535bb620b468936f884d2a"><div class="ttname"><a href="async_2task_8h.html#afca68102c0535bb620b468936f884d2a">monad_async_task_suspend_for_duration</a></div><div class="ttdeci">monad_async_result monad_async_task_suspend_for_duration(monad_async_io_status **completed, monad_async_task task, uint64_t ns)</div><div class="ttdoc">CANCELLATION POINT Suspend execution of a task for a given duration, which can be zero (which equates...</div></div>
<div class="ttc" id="aconfig_8h_html_ac4ae990e585e8fcb3923df7511c68ad9"><div class="ttname"><a href="config_8h.html#ac4ae990e585e8fcb3923df7511c68ad9">monad_async_make_success</a></div><div class="ttdeci">monad_async_result monad_async_make_success(intptr_t v)</div><div class="ttdoc">Return a successful monad_async_result for a given intptr_t</div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md11"></a>
Work dispatching to a thread pool</h2>
<p>Work dispatcher is simple but fast &ndash; any executor which finds itself with no work to do dequeues a new piece of work from the work dispatcher queue.</p>
<div class="fragment"><div class="line">monad_async_result r;</div>
<div class="line"><a class="code" href="structmonad__async__task__head.html">monad_async_task</a> tasks[1024];  <span class="comment">// tasks</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create a work dispatcher</span></div>
<div class="line"><a class="code" href="structmonad__async__work__dispatcher__head.html">monad_async_work_dispatcher</a> wd;</div>
<div class="line"><span class="keyword">struct </span><a class="code" href="structmonad__async__work__dispatcher__attr.html">monad_async_work_dispatcher_attr</a> wd_attr;</div>
<div class="line">memset(&amp;wd_attr, 0, <span class="keyword">sizeof</span>(wd_attr));</div>
<div class="line">r = <a class="code" href="work__dispatcher_8h.html#aea9f0962bcc9ed37ffd7eaba0c1e0057">monad_async_work_dispatcher_create</a>(&amp;wd, &amp;wd_attr);  <span class="comment">// expensive</span></div>
<div class="line">CHECK_RESULT(r);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create executors on thread to execute work</span></div>
<div class="line"><span class="comment">// (see below)</span></div>
<div class="line">create_executors_on_threads(wd);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Submit tasks to be executed. Each task&#39;s CPU priority will</span></div>
<div class="line"><span class="comment">// determine which get executed first.</span></div>
<div class="line">r = <a class="code" href="work__dispatcher_8h.html#aace405a76e521732a854b159027cc1eb">monad_async_work_dispatcher_submit</a>(wd, tasks, 1024);</div>
<div class="line">CHECK_RESULT(r);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Wait until all tasks have been dispatched and executed</span></div>
<div class="line">r = <a class="code" href="work__dispatcher_8h.html#a2e2debdea771ea3da824cfcec8bec19b">monad_async_work_dispatcher_wait</a>(wd, 0, 0, <span class="keyword">nullptr</span>);</div>
<div class="line">CHECK_RESULT(r);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Tell all executors to quit</span></div>
<div class="line">r = <a class="code" href="work__dispatcher_8h.html#a38112db863b6929daa41acda7b39e32b">monad_async_work_dispatcher_quit</a>(wd, MAX_SIZE_T, <span class="keyword">nullptr</span>);</div>
<div class="line">CHECK_RESULT(r);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Cleanup</span></div>
<div class="line">r = <a class="code" href="work__dispatcher_8h.html#a271ff0cc912dfde2e274e038f5394237">monad_async_work_dispatcher_destroy</a>(wd);</div>
<div class="line">CHECK_RESULT(r);</div>
<div class="ttc" id="astructmonad__async__work__dispatcher__attr_html"><div class="ttname"><a href="structmonad__async__work__dispatcher__attr.html">monad_async_work_dispatcher_attr</a></div><div class="ttdoc">Attributes by which to construct a work dispatcher.</div><div class="ttdef"><b>Definition:</b> work_dispatcher.h:49</div></div>
<div class="ttc" id="astructmonad__async__work__dispatcher__head_html"><div class="ttname"><a href="structmonad__async__work__dispatcher__head.html">monad_async_work_dispatcher_head</a></div><div class="ttdoc">The public attributes of a work dispatcher.</div><div class="ttdef"><b>Definition:</b> work_dispatcher.h:14</div></div>
<div class="ttc" id="awork__dispatcher_8h_html_a271ff0cc912dfde2e274e038f5394237"><div class="ttname"><a href="work__dispatcher_8h.html#a271ff0cc912dfde2e274e038f5394237">monad_async_work_dispatcher_destroy</a></div><div class="ttdeci">monad_async_result monad_async_work_dispatcher_destroy(monad_async_work_dispatcher dp)</div><div class="ttdoc">EXPENSIVE Destroys a work dispatcher instance.</div></div>
<div class="ttc" id="awork__dispatcher_8h_html_a2e2debdea771ea3da824cfcec8bec19b"><div class="ttname"><a href="work__dispatcher_8h.html#a2e2debdea771ea3da824cfcec8bec19b">monad_async_work_dispatcher_wait</a></div><div class="ttdeci">monad_async_result monad_async_work_dispatcher_wait(monad_async_work_dispatcher dp, size_t max_undispatched, size_t max_unexecuted, struct timespec *timeout)</div><div class="ttdoc">THREADSAFE Wait until all work has been dispatched or executed.</div></div>
<div class="ttc" id="awork__dispatcher_8h_html_a38112db863b6929daa41acda7b39e32b"><div class="ttname"><a href="work__dispatcher_8h.html#a38112db863b6929daa41acda7b39e32b">monad_async_work_dispatcher_quit</a></div><div class="ttdeci">monad_async_result monad_async_work_dispatcher_quit(monad_async_work_dispatcher dp, size_t max_executors, struct timespec *timeout)</div><div class="ttdoc">THREADSAFE Tells executors to quit, preferring idle executors first, until no more than max_executors...</div></div>
<div class="ttc" id="awork__dispatcher_8h_html_aace405a76e521732a854b159027cc1eb"><div class="ttname"><a href="work__dispatcher_8h.html#aace405a76e521732a854b159027cc1eb">monad_async_work_dispatcher_submit</a></div><div class="ttdeci">monad_async_result monad_async_work_dispatcher_submit(monad_async_work_dispatcher dp, monad_async_task *tasks, size_t count)</div><div class="ttdoc">THREADSAFE Submits one or more tasks to be executed by the first available executor within the work d...</div></div>
<div class="ttc" id="awork__dispatcher_8h_html_aea9f0962bcc9ed37ffd7eaba0c1e0057"><div class="ttname"><a href="work__dispatcher_8h.html#aea9f0962bcc9ed37ffd7eaba0c1e0057">monad_async_work_dispatcher_create</a></div><div class="ttdeci">monad_async_result monad_async_work_dispatcher_create(monad_async_work_dispatcher *dp, struct monad_async_work_dispatcher_attr *attr)</div><div class="ttdoc">EXPENSIVE Creates a work dispatcher instance.</div></div>
</div><!-- fragment --><p>An executor thread would look like:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> worker_thread(<a class="code" href="structmonad__async__work__dispatcher__head.html">monad_async_work_dispatcher</a> wd)</div>
<div class="line">{</div>
<div class="line">  monad_async_result r;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">struct </span><a class="code" href="structmonad__async__work__dispatcher__executor__attr.html">monad_async_work_dispatcher_executor_attr</a> ex_attr;</div>
<div class="line">  memset(&amp;ex_attr, 0, <span class="keyword">sizeof</span>(ex_attr));</div>
<div class="line">  <span class="comment">// Don&#39;t create an io_uring for this executor</span></div>
<div class="line">  <span class="comment">// This makes it into a pure-compute executor incapable of doing i/o</span></div>
<div class="line">  ex_attr.executor.io_uring_ring.entries = 0;</div>
<div class="line">  r = <a class="code" href="work__dispatcher_8h.html#a6c96681377b6ba5431afc79ae66fe475">monad_async_work_dispatcher_executor_create</a>(&amp;ex, wd, &amp;ex_attr);</div>
<div class="line">  CHECK_RESULT(r);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Loop executing work until told to quit</span></div>
<div class="line">  <span class="keywordflow">for</span>(;;)</div>
<div class="line">  {</div>
<div class="line">    r = <a class="code" href="work__dispatcher_8h.html#a01dae157c52d239202aad1ae282b2019">monad_async_work_dispatcher_executor_run</a>(ex);</div>
<div class="line">    CHECK_RESULT(r);</div>
<div class="line">    <span class="keywordflow">if</span>(r.value &lt; 0)</div>
<div class="line">    {</div>
<div class="line">      <span class="keywordflow">break</span>;</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Cleanup</span></div>
<div class="line">  r = <a class="code" href="work__dispatcher_8h.html#a6cfb10eefdf5a391506bc69eae3a5300">monad_async_work_dispatcher_executor_destroy</a>(ex);</div>
<div class="line">  CHECK_RESULT(r);</div>
<div class="line">}</div>
<div class="ttc" id="astructmonad__async__work__dispatcher__executor__attr_html"><div class="ttname"><a href="structmonad__async__work__dispatcher__executor__attr.html">monad_async_work_dispatcher_executor_attr</a></div><div class="ttdoc">Attributes by which to construct a work dispatcher.</div><div class="ttdef"><b>Definition:</b> work_dispatcher.h:57</div></div>
<div class="ttc" id="awork__dispatcher_8h_html_a01dae157c52d239202aad1ae282b2019"><div class="ttname"><a href="work__dispatcher_8h.html#a01dae157c52d239202aad1ae282b2019">monad_async_work_dispatcher_executor_run</a></div><div class="ttdeci">monad_async_result monad_async_work_dispatcher_executor_run(monad_async_work_dispatcher_executor ex)</div><div class="ttdoc">Calls monad_async_executor_run() for the calling kernel thread, attaching tasks recently submitted to...</div></div>
<div class="ttc" id="awork__dispatcher_8h_html_a6c96681377b6ba5431afc79ae66fe475"><div class="ttname"><a href="work__dispatcher_8h.html#a6c96681377b6ba5431afc79ae66fe475">monad_async_work_dispatcher_executor_create</a></div><div class="ttdeci">monad_async_result monad_async_work_dispatcher_executor_create(monad_async_work_dispatcher_executor *ex, monad_async_work_dispatcher dp, struct monad_async_work_dispatcher_executor_attr *attr)</div><div class="ttdoc">EXPENSIVE Creates a work dispatcher executor instance.</div></div>
<div class="ttc" id="awork__dispatcher_8h_html_a6cfb10eefdf5a391506bc69eae3a5300"><div class="ttname"><a href="work__dispatcher_8h.html#a6cfb10eefdf5a391506bc69eae3a5300">monad_async_work_dispatcher_executor_destroy</a></div><div class="ttdeci">monad_async_result monad_async_work_dispatcher_executor_destroy(monad_async_work_dispatcher_executor ex)</div><div class="ttdoc">EXPENSIVE Destroys a work dispatcher executor instance.</div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md12"></a>
File i/o</h2>
<p>From a task's perspective, file i/o is implemented in the same way as how the NT kernel's alertable i/o is implemented, which to my best knowledge is the optimal way. There is a queue of initiated i/o and another queue of completed i/o. When your task suspends, i/o can move from the initiated queue to the completed queue. When your task resumes, it is on you to dequeue any completed i/o.</p>
<p>As with the NT kernel's <code>IOSTATUS</code> structure which uniquely identifies each i/o in flight, the <code><a class="el" href="structmonad__async__io__status.html" title="An i/o status state used to identify an i/o in progress. Must NOT move in memory until the operation ...">monad_async_io_status</a></code> structure does the same. You supply the <code><a class="el" href="structmonad__async__io__status.html" title="An i/o status state used to identify an i/o in progress. Must NOT move in memory until the operation ...">monad_async_io_status</a></code> structure instance for every i/o you initiate. It will get asynchronously completed with the result of the i/o.</p>
<p>Both registered buffer i/o and non-registered buffer i/o</p>
<div class="fragment"><div class="line"><span class="keyword">static</span> monad_async_result mytask(<a class="code" href="structmonad__async__task__head.html">monad_async_task</a> task)</div>
<div class="line">{</div>
<div class="line">  monad_async_result r;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Open a file for read. This will suspend the task and resume</span></div>
<div class="line">  <span class="comment">// it after the file has been opened.</span></div>
<div class="line">  <span class="keyword">struct </span>open_how how = {</div>
<div class="line">      .flags = O_RDONLY, .mode = 0, .resolve = 0</div>
<div class="line">  };</div>
<div class="line">  <a class="code" href="structmonad__async__file__head.html">monad_async_file</a> fh;</div>
<div class="line">  r = <a class="code" href="file__io_8h.html#ac693542f584a82079e0c5972972c75bf">monad_async_task_file_create</a>(&amp;fh, task, <span class="keyword">nullptr</span>, <span class="stringliteral">&quot;foo.txt&quot;</span>, &amp;how);</div>
<div class="line">  CHECK_RESULT(r);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Get a registered buffer for read</span></div>
<div class="line">  <a class="code" href="structmonad__async__executor__registered__io__buffer.html">monad_async_executor_registered_io_buffer</a> buffer;</div>
<div class="line">  r = <a class="code" href="executor_8h.html#aafe107b73e4560dac6ecf633d85a89d0">monad_async_executor_claim_registered_io_buffer</a>(</div>
<div class="line">                &amp;buffer, task-&gt;<a class="code" href="structmonad__async__task__head.html#a161bfc0d06d9c82bc80d5c73737f9c3c">current_executor</a>, 64, <span class="keyword">false</span>);</div>
<div class="line">  CHECK_RESULT(r);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Initiate a read. It may suspend and resume the task if there</span></div>
<div class="line">  <span class="comment">// are no more io_uring sqes available.</span></div>
<div class="line">  <a class="code" href="structmonad__async__io__status.html">monad_async_io_status</a> iostatus;</div>
<div class="line">  memset(&amp;iostatus, 0, <span class="keyword">sizeof</span>(iostatus));</div>
<div class="line">  <a class="code" href="file__io_8h.html#adda864ad452f7d7c7c4757a35bbaf149">monad_async_task_file_read</a>(</div>
<div class="line">      &amp;iostatus,     <span class="comment">// i/o status to use</span></div>
<div class="line">      task,          <span class="comment">// this task</span></div>
<div class="line">      fh.get(),      <span class="comment">// open file to use</span></div>
<div class="line">      buffer.<a class="code" href="structmonad__async__executor__registered__io__buffer.html#a6e3242335b8f2b3da652b39bc7a1da39">index</a>,  <span class="comment">// can be zero if use unregistered buffer</span></div>
<div class="line">      buffer.<a class="code" href="structmonad__async__executor__registered__io__buffer.html#a02b0e05b70965a6e841e78683238b616">iov</a>,    <span class="comment">// struct iovec[] sequence</span></div>
<div class="line">      1,             <span class="comment">// length of struct iovec[] sequence</span></div>
<div class="line">      0,             <span class="comment">// offset to use</span></div>
<div class="line">      0);            <span class="comment">// preadv2 flags to use</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Reap i/o completions, suspending the task until more completions</span></div>
<div class="line">  <span class="comment">// appear</span></div>
<div class="line">  <span class="keywordflow">for</span>(;;){</div>
<div class="line">    <a class="code" href="structmonad__async__io__status.html">monad_async_io_status</a> *completed;</div>
<div class="line">    r = monad_async_task_suspend_until_completed_io(&amp;completed, task, (uint64_t)-1);</div>
<div class="line">    CHECK_RESULT(r);</div>
<div class="line">    <span class="keywordflow">if</span>(r.value == 0) {</div>
<div class="line">      <span class="keywordflow">break</span>;</div>
<div class="line">    }</div>
<div class="line">    <span class="comment">/* handle completed ... */</span></div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Release the registered buffer</span></div>
<div class="line">  r = <a class="code" href="executor_8h.html#ab00e50ea8ff3e5015d4e5d65e9ddb0ba">monad_async_executor_release_registered_io_buffer</a>(</div>
<div class="line">                          task-&gt;<a class="code" href="structmonad__async__task__head.html#a161bfc0d06d9c82bc80d5c73737f9c3c">current_executor</a>, buffer.<a class="code" href="structmonad__async__executor__registered__io__buffer.html#a6e3242335b8f2b3da652b39bc7a1da39">index</a>);</div>
<div class="line">  CHECK_RESULT(r);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Close the file, This will suspend the task and resume it</span></div>
<div class="line">  <span class="comment">// after the file has been closed.</span></div>
<div class="line">  r = <a class="code" href="file__io_8h.html#a3304c17ba026de35040e9ef2c885b8f5">monad_async_task_file_destroy</a>(task, fh);</div>
<div class="line">  CHECK_RESULT(r);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// All done, return success</span></div>
<div class="line">  <span class="keywordflow">return</span> <a class="code" href="config_8h.html#ac4ae990e585e8fcb3923df7511c68ad9">monad_async_make_success</a>(0);</div>
<div class="line">}</div>
<div class="ttc" id="aexecutor_8h_html_aafe107b73e4560dac6ecf633d85a89d0"><div class="ttname"><a href="executor_8h.html#aafe107b73e4560dac6ecf633d85a89d0">monad_async_executor_claim_registered_io_buffer</a></div><div class="ttdeci">monad_async_result monad_async_executor_claim_registered_io_buffer(monad_async_executor_registered_io_buffer *buffer, monad_async_executor ex, size_t bytes_requested, bool is_for_write)</div><div class="ttdoc">Claim an unused registered buffer, if there is one.</div></div>
<div class="ttc" id="aexecutor_8h_html_ab00e50ea8ff3e5015d4e5d65e9ddb0ba"><div class="ttname"><a href="executor_8h.html#ab00e50ea8ff3e5015d4e5d65e9ddb0ba">monad_async_executor_release_registered_io_buffer</a></div><div class="ttdeci">monad_async_result monad_async_executor_release_registered_io_buffer(monad_async_executor ex, int buffer_index)</div><div class="ttdoc">Release a previously claimed registered buffer.</div></div>
<div class="ttc" id="afile__io_8h_html_a3304c17ba026de35040e9ef2c885b8f5"><div class="ttname"><a href="file__io_8h.html#a3304c17ba026de35040e9ef2c885b8f5">monad_async_task_file_destroy</a></div><div class="ttdeci">monad_async_result monad_async_task_file_destroy(monad_async_task task, monad_async_file file)</div><div class="ttdoc">Suspend execution of the task until the file has been closed.</div></div>
<div class="ttc" id="afile__io_8h_html_ac693542f584a82079e0c5972972c75bf"><div class="ttname"><a href="file__io_8h.html#ac693542f584a82079e0c5972972c75bf">monad_async_task_file_create</a></div><div class="ttdeci">monad_async_result monad_async_task_file_create(monad_async_file *file, monad_async_task task, monad_async_file base, char const *subpath, struct open_how *how)</div><div class="ttdoc">EXPENSIVE, CANCELLATION POINT Suspend execution of the task until the file has been opened....</div></div>
<div class="ttc" id="afile__io_8h_html_adda864ad452f7d7c7c4757a35bbaf149"><div class="ttname"><a href="file__io_8h.html#adda864ad452f7d7c7c4757a35bbaf149">monad_async_task_file_read</a></div><div class="ttdeci">void monad_async_task_file_read(monad_async_io_status *iostatus, monad_async_task task, monad_async_file file, int buffer_index, const struct iovec *iovecs, unsigned nr_vecs, monad_async_file_offset offset, int flags)</div><div class="ttdoc">Initiate a read from an open file using iostatus as the identifier.</div></div>
<div class="ttc" id="astructmonad__async__executor__registered__io__buffer_html"><div class="ttname"><a href="structmonad__async__executor__registered__io__buffer.html">monad_async_executor_registered_io_buffer</a></div><div class="ttdoc">A registered i/o buffer.</div><div class="ttdef"><b>Definition:</b> executor.h:84</div></div>
<div class="ttc" id="astructmonad__async__executor__registered__io__buffer_html_a02b0e05b70965a6e841e78683238b616"><div class="ttname"><a href="structmonad__async__executor__registered__io__buffer.html#a02b0e05b70965a6e841e78683238b616">monad_async_executor_registered_io_buffer::iov</a></div><div class="ttdeci">struct iovec iov[1]</div><div class="ttdef"><b>Definition:</b> executor.h:86</div></div>
<div class="ttc" id="astructmonad__async__executor__registered__io__buffer_html_a6e3242335b8f2b3da652b39bc7a1da39"><div class="ttname"><a href="structmonad__async__executor__registered__io__buffer.html#a6e3242335b8f2b3da652b39bc7a1da39">monad_async_executor_registered_io_buffer::index</a></div><div class="ttdeci">int index</div><div class="ttdef"><b>Definition:</b> executor.h:85</div></div>
<div class="ttc" id="astructmonad__async__file__head_html"><div class="ttname"><a href="structmonad__async__file__head.html">monad_async_file_head</a></div><div class="ttdoc">The public attributes of an open file.</div><div class="ttdef"><b>Definition:</b> file_io.h:17</div></div>
<div class="ttc" id="astructmonad__async__io__status_html"><div class="ttname"><a href="structmonad__async__io__status.html">monad_async_io_status</a></div><div class="ttdoc">An i/o status state used to identify an i/o in progress. Must NOT move in memory until the operation ...</div><div class="ttdef"><b>Definition:</b> task.h:23</div></div>
<div class="ttc" id="astructmonad__async__task__head_html_a161bfc0d06d9c82bc80d5c73737f9c3c"><div class="ttname"><a href="structmonad__async__task__head.html#a161bfc0d06d9c82bc80d5c73737f9c3c">monad_async_task_head::current_executor</a></div><div class="ttdeci">_Atomic monad_async_executor current_executor</div><div class="ttdef"><b>Definition:</b> task.h:82</div></div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md13"></a>
Todo</h1>
<ul>
<li>Rename <code>monad_async_*</code> to <code>monad_executor_io_*</code>.</li>
<li>Rename <code>monad_fiber_*</code> to <code>monad_executor_compute_*</code>?</li>
<li>Need to test cancellation works at every possible lifecycle and suspend state a task can have.</li>
<li>A test should make 1 billion tasks to prove it works without issue and scales without issue.</li>
<li>A context switcher implementing C++ coroutines would be nice. Some notes on that:<ul>
<li>MSVC coroutine frame: Promise | Frame prefix | Local variables. Coroutine frame is: <code>struct msvc_frame_prefix { void(*factivate)(void*); uint16_t index, flag; };</code>. Implementation is a state machine based on switching <code>index</code>.</li>
<li>GCC/clang coroutine frame: Frame prefix | Promise | Unknown | Local variables. Coroutine frame is: <code>struct clang_frame_prefix { void(*factivate)(void*); void(*fdestroy)(void*);};</code>. </li>
</ul>
</li>
</ul>
</div></div><!-- PageDoc -->
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
