#include <monad/core/byte_string.hpp>
#include <monad/core/receipt.hpp>
#include <monad/core/rlp/receipt_rlp.hpp>
#include <monad/core/transaction.hpp>

#include <evmc/evmc.hpp>

#include <gtest/gtest.h>

#include <cstddef>
#include <cstdint>

using namespace monad;
using namespace monad::rlp;

TEST(Rlp_Receipt, DecodeEncodeLog)
{
    // Empty Log
    {
        Receipt::Log const empty_log{};
        static byte_string const empty_rlp{0xd7, 0x94, 0x00, 0x00, 0x00, 0x00,
                                           0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                                           0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                                           0x00, 0x00, 0x00, 0x00, 0xc0, 0x80};
        auto const encoded = encode_log(empty_log);
        EXPECT_EQ(encoded, empty_rlp);
    }

    // Actual Log
    {
        static constexpr auto addr{
            0x3535353535353535353535353535353535353535_address};
        static constexpr auto topic1{
            0xbea34dd04b09ad3b6014251ee24578074087ee60fda8c391cf466dfe5d687d7b_bytes32};
        static constexpr auto topic2{
            0x6b8cebdc2590b486457bbb286e96011bdd50ccc1d8580c1ffb3c89e828462283_bytes32};
        static byte_string const data{0x00, 0x01, 0x02, 0x03};
        Receipt::Log log{
            .data = data, .topics = {topic1, topic2}, .address = addr};

        byte_string const rlp_log{
            0xf8, 0x5e, 0x94, 0x35, 0x35, 0x35, 0x35, 0x35, 0x35, 0x35, 0x35,
            0x35, 0x35, 0x35, 0x35, 0x35, 0x35, 0x35, 0x35, 0x35, 0x35, 0x35,
            0x35, 0xf8, 0x42, 0xa0, 0xbe, 0xa3, 0x4d, 0xd0, 0x4b, 0x09, 0xad,
            0x3b, 0x60, 0x14, 0x25, 0x1e, 0xe2, 0x45, 0x78, 0x07, 0x40, 0x87,
            0xee, 0x60, 0xfd, 0xa8, 0xc3, 0x91, 0xcf, 0x46, 0x6d, 0xfe, 0x5d,
            0x68, 0x7d, 0x7b, 0xa0, 0x6b, 0x8c, 0xeb, 0xdc, 0x25, 0x90, 0xb4,
            0x86, 0x45, 0x7b, 0xbb, 0x28, 0x6e, 0x96, 0x01, 0x1b, 0xdd, 0x50,
            0xcc, 0xc1, 0xd8, 0x58, 0x0c, 0x1f, 0xfb, 0x3c, 0x89, 0xe8, 0x28,
            0x46, 0x22, 0x83, 0x84, 0x00, 0x01, 0x02, 0x03};
        auto const encoded = encode_log(log);
        EXPECT_EQ(encoded, rlp_log);

        byte_string_view encoded_log_view{encoded};
        auto const decoded_log_outcome = decode_log(encoded_log_view);
        ASSERT_FALSE(decoded_log_outcome.has_error());
        EXPECT_EQ(encoded_log_view.size(), 0);

        auto const& decoded_log = decoded_log_outcome.value();
        EXPECT_EQ(decoded_log.data, log.data);
        EXPECT_EQ(decoded_log.address, log.address);

        EXPECT_EQ(decoded_log.topics.size(), log.topics.size());
        EXPECT_EQ(decoded_log.topics[0], log.topics[0]);
        EXPECT_EQ(decoded_log.topics[1], log.topics[1]);
    }
}

TEST(Rlp_Receipt, DecodeEncodeBloom)
{
    static Receipt::Bloom bloom{};
    bloom[0] = 0x02;
    bloom[78] = 0x01;
    bloom[182] = 0x01;
    bloom[232] = 0x01;
    bloom[255] = 0x02;
    byte_string const rlp_bloom{
        0xb9, 0x01, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02};

    auto const encoded = encode_bloom(bloom);
    EXPECT_EQ(encoded, rlp_bloom);

    byte_string_view encoded_bloom_view{encoded};
    auto const decoded_bloom = decode_bloom(encoded_bloom_view);
    ASSERT_FALSE(decoded_bloom.has_error());
    EXPECT_EQ(encoded_bloom_view.size(), 0);
    EXPECT_EQ(decoded_bloom.value(), bloom);
}

TEST(Rlp_Receipt, DecodeEncodeEip155Receipt)
{
    using namespace evmc::literals;

    static constexpr uint64_t gas{2'850'010};
    static constexpr auto addr{
        0x3535353535353535353535353535353535353535_address};
    static constexpr auto topic1{
        0xbea34dd04b09ad3b6014251ee24578074087ee60fda8c391cf466dfe5d687d7b_bytes32};
    static constexpr auto topic2{
        0x6b8cebdc2590b486457bbb286e96011bdd50ccc1d8580c1ffb3c89e828462283_bytes32};
    static byte_string const data{0x00, 0x01, 0x02, 0x03};
    static Receipt::Bloom bloom{};
    bloom[78] = 0x01;
    bloom[182] = 0x01;
    bloom[232] = 0x01;
    Receipt::Log log{.data = data, .topics = {topic1, topic2}, .address = addr};
    Receipt const r{
        .bloom = bloom,
        .gas_used = gas,
        .type = TransactionType::legacy,
        .logs = {log}};
    byte_string const rlp_receipt{
        0xf9, 0x01, 0x6a, 0x80, 0x83, 0x2b, 0x7c, 0xda, // status and gas

        0xb9, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // bloom filter

        0xf8, 0x60, 0xf8, 0x5e, 0x94, 0x35, 0x35, 0x35, 0x35, 0x35, 0x35, 0x35,
        0x35, 0x35, 0x35, 0x35, 0x35, 0x35, 0x35, 0x35, 0x35, 0x35, 0x35, 0x35,
        0x35, 0xf8, 0x42, 0xa0, 0xbe, 0xa3, 0x4d, 0xd0, 0x4b, 0x09, 0xad, 0x3b,
        0x60, 0x14, 0x25, 0x1e, 0xe2, 0x45, 0x78, 0x07, 0x40, 0x87, 0xee, 0x60,
        0xfd, 0xa8, 0xc3, 0x91, 0xcf, 0x46, 0x6d, 0xfe, 0x5d, 0x68, 0x7d, 0x7b,
        0xa0, 0x6b, 0x8c, 0xeb, 0xdc, 0x25, 0x90, 0xb4, 0x86, 0x45, 0x7b, 0xbb,
        0x28, 0x6e, 0x96, 0x01, 0x1b, 0xdd, 0x50, 0xcc, 0xc1, 0xd8, 0x58, 0x0c,
        0x1f, 0xfb, 0x3c, 0x89, 0xe8, 0x28, 0x46, 0x22, 0x83, 0x84, 0x00, 0x01,
        0x02, 0x03}; // logs
    auto const encoded = encode_receipt(r);
    EXPECT_EQ(encoded, rlp_receipt);

    byte_string_view encoded_receipt_view{encoded};
    auto const decoded_receipt_outcome = decode_receipt(encoded_receipt_view);
    ASSERT_FALSE(decoded_receipt_outcome.has_error());
    EXPECT_EQ(encoded_receipt_view.size(), 0);

    auto const& decoded_receipt = decoded_receipt_outcome.value();

    EXPECT_EQ(decoded_receipt.type, r.type);
    EXPECT_EQ(decoded_receipt.gas_used, r.gas_used);
    EXPECT_EQ(decoded_receipt.status, r.status);

    // Bloom
    EXPECT_EQ(decoded_receipt.bloom, r.bloom);

    // Log
    EXPECT_EQ(decoded_receipt.logs.size(), r.logs.size());
    for (size_t i = 0u; i < decoded_receipt.logs.size(); ++i) {
        EXPECT_EQ(decoded_receipt.logs[i].address, r.logs[i].address);
        EXPECT_EQ(
            decoded_receipt.logs[i].topics.size(),
            r.logs[i].topics.size());
        EXPECT_EQ(decoded_receipt.logs[i].topics, r.logs[i].topics);
        EXPECT_EQ(decoded_receipt.logs[i].address, r.logs[i].address);
    }
}

TEST(Rlp_Receipt, DecodeEncodeReceiptLogSize)
{
    using namespace evmc::literals;

    static constexpr uint64_t gas{2'850'010};
    static constexpr auto addr{
        0x3535353535353535353535353535353535353535_address};
    static constexpr auto topic1{
        0xbea34dd04b09ad3b6014251ee24578074087ee60fda8c391cf466dfe5d687d7b_bytes32};
    static constexpr auto topic2{
        0x6b8cebdc2590b486457bbb286e96011bdd50ccc1d8580c1ffb3c89e828462283_bytes32};
    static byte_string const data{0x00, 0x01, 0x02, 0x03};
    static Receipt::Bloom bloom{};
    bloom[78] = 0x01;
    bloom[182] = 0x01;
    bloom[232] = 0x01;

    Receipt::Log log{.data = data, .topics = {topic1, topic2, topic1, topic2, topic1, topic2, topic1, topic2, topic1, topic2, topic1}, .address = addr};
    Receipt const r{
        .bloom = bloom,
        .gas_used = gas,
        .type = TransactionType::legacy,
        .logs = {log}};
    auto const encoded = encode_receipt(r);

    byte_string_view encoded_receipt_view{encoded};
    auto const decoded_receipt_outcome = decode_receipt(encoded_receipt_view);
    ASSERT_FALSE(decoded_receipt_outcome.has_error());
    auto const& decoded_receipt = decoded_receipt_outcome.value();

    EXPECT_EQ(encoded_receipt_view.size(), 0);

    EXPECT_EQ(decoded_receipt.type, r.type);
    EXPECT_EQ(decoded_receipt.gas_used, r.gas_used);
    EXPECT_EQ(decoded_receipt.status, r.status);

    // Bloom
    EXPECT_EQ(decoded_receipt.bloom, r.bloom);

    // Log
    EXPECT_EQ(decoded_receipt.logs.size(), r.logs.size());

    for (size_t i = 0u; i < decoded_receipt.logs.size(); ++i) {
        EXPECT_EQ(decoded_receipt.logs[i].address, r.logs[i].address);
        EXPECT_EQ(
            decoded_receipt.logs[i].topics.size(),
            r.logs[i].topics.size());
        EXPECT_EQ(decoded_receipt.logs[i].topics, r.logs[i].topics);
        EXPECT_EQ(decoded_receipt.logs[i].address, r.logs[i].address);
    }
}

TEST(Rlp_Receipt, EncodeEip1559Receipt)
{
    using namespace evmc::literals;

    static constexpr uint64_t gas{2'850'010};
    static constexpr auto addr{
        0x3535353535353535353535353535353535353535_address};
    static constexpr auto topic1{
        0xbea34dd04b09ad3b6014251ee24578074087ee60fda8c391cf466dfe5d687d7b_bytes32};
    static constexpr auto topic2{
        0x6b8cebdc2590b486457bbb286e96011bdd50ccc1d8580c1ffb3c89e828462283_bytes32};
    static byte_string const data{0x00, 0x01, 0x02, 0x03};
    static Receipt::Bloom bloom{};
    bloom[78] = 0x01;
    bloom[182] = 0x01;
    bloom[232] = 0x01;
    Receipt::Log log{.data = data, .topics = {topic1, topic2}, .address = addr};
    Receipt const r{
        .bloom = bloom,
        .gas_used = gas,
        .type = TransactionType::eip1559,
        .logs = {log}};
    byte_string const rlp_receipt{
        0x02, // type envelope

        0xf9, 0x01, 0x6a, 0x80, 0x83, 0x2b, 0x7c, 0xda, // status and gas

        0xb9, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // bloom filter

        0xf8, 0x60, 0xf8, 0x5e, 0x94, 0x35, 0x35, 0x35, 0x35, 0x35, 0x35, 0x35,
        0x35, 0x35, 0x35, 0x35, 0x35, 0x35, 0x35, 0x35, 0x35, 0x35, 0x35, 0x35,
        0x35, 0xf8, 0x42, 0xa0, 0xbe, 0xa3, 0x4d, 0xd0, 0x4b, 0x09, 0xad, 0x3b,
        0x60, 0x14, 0x25, 0x1e, 0xe2, 0x45, 0x78, 0x07, 0x40, 0x87, 0xee, 0x60,
        0xfd, 0xa8, 0xc3, 0x91, 0xcf, 0x46, 0x6d, 0xfe, 0x5d, 0x68, 0x7d, 0x7b,
        0xa0, 0x6b, 0x8c, 0xeb, 0xdc, 0x25, 0x90, 0xb4, 0x86, 0x45, 0x7b, 0xbb,
        0x28, 0x6e, 0x96, 0x01, 0x1b, 0xdd, 0x50, 0xcc, 0xc1, 0xd8, 0x58, 0x0c,
        0x1f, 0xfb, 0x3c, 0x89, 0xe8, 0x28, 0x46, 0x22, 0x83, 0x84, 0x00, 0x01,
        0x02, 0x03}; // logs
    auto const encoded = encode_receipt(r);
    EXPECT_EQ(encoded, rlp_receipt);

    byte_string_view encoded_receipt_view{encoded};
    auto const decoded_receipt_outcome = decode_receipt(encoded_receipt_view);
    ASSERT_FALSE(decoded_receipt_outcome.has_error());
    EXPECT_EQ(encoded_receipt_view.size(), 0);

    auto const& decoded_receipt = decoded_receipt_outcome.value();
    EXPECT_EQ(decoded_receipt.type, r.type);
    EXPECT_EQ(decoded_receipt.gas_used, r.gas_used);
    EXPECT_EQ(decoded_receipt.status, r.status);

    // Bloom
    EXPECT_EQ(decoded_receipt.bloom, r.bloom);

    // Log
    EXPECT_EQ(decoded_receipt.logs.size(), r.logs.size());
    for (size_t i = 0u; i < decoded_receipt.logs.size(); ++i) {
        EXPECT_EQ(decoded_receipt.logs[i].address, r.logs[i].address);
        EXPECT_EQ(
            decoded_receipt.logs[i].topics.size(),
            r.logs[i].topics.size());
        EXPECT_EQ(decoded_receipt.logs[i].topics, r.logs[i].topics);
        EXPECT_EQ(decoded_receipt.logs[i].address, r.logs[i].address);
    }
}

TEST(Rlp_Receipt, EncodeEip2930Receipt)
{
    using namespace evmc::literals;

    static constexpr uint64_t gas{2'850'010};
    static constexpr auto addr{
        0x3535353535353535353535353535353535353535_address};
    static constexpr auto topic1{
        0xbea34dd04b09ad3b6014251ee24578074087ee60fda8c391cf466dfe5d687d7b_bytes32};
    static constexpr auto topic2{
        0x6b8cebdc2590b486457bbb286e96011bdd50ccc1d8580c1ffb3c89e828462283_bytes32};
    static byte_string const data{0x00, 0x01, 0x02, 0x03};
    static Receipt::Bloom bloom{};
    bloom[78] = 0x01;
    bloom[182] = 0x01;
    bloom[232] = 0x01;
    Receipt::Log log{.data = data, .topics = {topic1, topic2}, .address = addr};
    Receipt const r{
        .bloom = bloom,
        .gas_used = gas,
        .type = TransactionType::eip2930,
        .logs = {log}};
    byte_string const rlp_receipt{
        0x01, // type envelope

        0xf9, 0x01, 0x6a, 0x80, 0x83, 0x2b, 0x7c, 0xda, // status and gas

        0xb9, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // bloom filter

        0xf8, 0x60, 0xf8, 0x5e, 0x94, 0x35, 0x35, 0x35, 0x35, 0x35, 0x35, 0x35,
        0x35, 0x35, 0x35, 0x35, 0x35, 0x35, 0x35, 0x35, 0x35, 0x35, 0x35, 0x35,
        0x35, 0xf8, 0x42, 0xa0, 0xbe, 0xa3, 0x4d, 0xd0, 0x4b, 0x09, 0xad, 0x3b,
        0x60, 0x14, 0x25, 0x1e, 0xe2, 0x45, 0x78, 0x07, 0x40, 0x87, 0xee, 0x60,
        0xfd, 0xa8, 0xc3, 0x91, 0xcf, 0x46, 0x6d, 0xfe, 0x5d, 0x68, 0x7d, 0x7b,
        0xa0, 0x6b, 0x8c, 0xeb, 0xdc, 0x25, 0x90, 0xb4, 0x86, 0x45, 0x7b, 0xbb,
        0x28, 0x6e, 0x96, 0x01, 0x1b, 0xdd, 0x50, 0xcc, 0xc1, 0xd8, 0x58, 0x0c,
        0x1f, 0xfb, 0x3c, 0x89, 0xe8, 0x28, 0x46, 0x22, 0x83, 0x84, 0x00, 0x01,
        0x02, 0x03}; // logs
    auto const encoded = encode_receipt(r);
    EXPECT_EQ(encoded, rlp_receipt);

    byte_string_view encoded_receipt_view{encoded};
    auto const decoded_receipt_outcome = decode_receipt(encoded_receipt_view);
    ASSERT_FALSE(decoded_receipt_outcome.has_error());
    EXPECT_EQ(encoded_receipt_view.size(), 0);

    auto const& decoded_receipt = decoded_receipt_outcome.value();
    EXPECT_EQ(decoded_receipt.type, r.type);
    EXPECT_EQ(decoded_receipt.gas_used, r.gas_used);
    EXPECT_EQ(decoded_receipt.status, r.status);

    // Bloom
    EXPECT_EQ(decoded_receipt.bloom, r.bloom);

    // Log
    EXPECT_EQ(decoded_receipt.logs.size(), r.logs.size());
    for (size_t i = 0u; i < decoded_receipt.logs.size(); ++i) {
        EXPECT_EQ(decoded_receipt.logs[i].address, r.logs[i].address);
        EXPECT_EQ(
            decoded_receipt.logs[i].topics.size(),
            r.logs[i].topics.size());
        EXPECT_EQ(decoded_receipt.logs[i].topics, r.logs[i].topics);
        EXPECT_EQ(decoded_receipt.logs[i].address, r.logs[i].address);
    }
}
