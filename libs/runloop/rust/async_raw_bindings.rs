/* automatically generated by rust-bindgen 0.71.1 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    fn extract_bit(byte: u8, index: usize) -> bool {
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        Self::extract_bit(byte, index)
    }
    #[inline]
    pub unsafe fn raw_get_bit(this: *const Self, index: usize) -> bool {
        debug_assert!(index / 8 < core::mem::size_of::<Storage>());
        let byte_index = index / 8;
        let byte = *(core::ptr::addr_of!((*this).storage) as *const u8).offset(byte_index as isize);
        Self::extract_bit(byte, index)
    }
    #[inline]
    fn change_bit(byte: u8, index: usize, val: bool) -> u8 {
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            byte | mask
        } else {
            byte & !mask
        }
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        *byte = Self::change_bit(*byte, index, val);
    }
    #[inline]
    pub unsafe fn raw_set_bit(this: *mut Self, index: usize, val: bool) {
        debug_assert!(index / 8 < core::mem::size_of::<Storage>());
        let byte_index = index / 8;
        let byte =
            (core::ptr::addr_of_mut!((*this).storage) as *mut u8).offset(byte_index as isize);
        *byte = Self::change_bit(*byte, index, val);
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub unsafe fn raw_get(this: *const Self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < core::mem::size_of::<Storage>());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= core::mem::size_of::<Storage>());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if Self::raw_get_bit(this, i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
    #[inline]
    pub unsafe fn raw_set(this: *mut Self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < core::mem::size_of::<Storage>());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= core::mem::size_of::<Storage>());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            Self::raw_set_bit(this, index + bit_offset, val_bit_is_set);
        }
    }
}
#[repr(C)]
pub struct __BindgenUnionField<T>(::std::marker::PhantomData<T>);
impl<T> __BindgenUnionField<T> {
    #[inline]
    pub const fn new() -> Self {
        __BindgenUnionField(::std::marker::PhantomData)
    }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T {
        ::std::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T {
        ::std::mem::transmute(self)
    }
}
impl<T> ::std::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self {
        Self::new()
    }
}
impl<T> ::std::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self {
        *self
    }
}
impl<T> ::std::marker::Copy for __BindgenUnionField<T> {}
impl<T> ::std::fmt::Debug for __BindgenUnionField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.write_str("__BindgenUnionField")
    }
}
impl<T> ::std::hash::Hash for __BindgenUnionField<T> {
    fn hash<H: ::std::hash::Hasher>(&self, _state: &mut H) {}
}
impl<T> ::std::cmp::PartialEq for __BindgenUnionField<T> {
    fn eq(&self, _other: &__BindgenUnionField<T>) -> bool {
        true
    }
}
impl<T> ::std::cmp::Eq for __BindgenUnionField<T> {}
pub type __time_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn outcome_make_result_status_code_success(
        out: *mut ::std::os::raw::c_void,
        bytes: usize,
        offset: usize,
        toset: *const ::std::os::raw::c_void,
        tosetbytes: usize,
    );
}
unsafe extern "C" {
    pub fn outcome_make_result_status_code_failure_posix(
        out: *mut ::std::os::raw::c_void,
        bytes: usize,
        offset: usize,
        errcode: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    pub fn outcome_make_result_status_code_failure_system(
        out: *mut ::std::os::raw::c_void,
        bytes: usize,
        offset: usize,
        errcode: isize,
    );
}
unsafe extern "C" {
    pub fn outcome_status_code_equal(
        a: *const ::std::os::raw::c_void,
        b: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn outcome_status_code_equal_generic(
        a: *const ::std::os::raw::c_void,
        errcode: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn outcome_status_code_message(
        a: *const ::std::os::raw::c_void,
    ) -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cxx_status_code_system {
    pub domain: *mut ::std::os::raw::c_void,
    pub value: isize,
}
impl Default for cxx_status_code_system {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[doc = "! \\brief Declare a Boost.Outcome layout compatible C result type for\n! `result<intptr_t>`"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cxx_result_status_code_system_monad {
    #[doc = "! \\brief Declare a Boost.Outcome layout compatible C result type for\n! `result<intptr_t>`"]
    pub value: isize,
    pub flags: ::std::os::raw::c_uint,
    pub error: cxx_status_code_system,
}
impl Default for cxx_result_status_code_system_monad {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    #[doc = "! \\brief Declare a Boost.Outcome layout compatible C result type for\n! `result<intptr_t>`"]
    pub fn outcome_make_result_system_monad_failure_posix(
        errcode: ::std::os::raw::c_int,
    ) -> cxx_result_status_code_system_monad;
}
unsafe extern "C" {
    #[doc = "! \\brief Declare a Boost.Outcome layout compatible C result type for\n! `result<intptr_t>`"]
    pub fn outcome_make_result_system_monad_failure_system(
        errcode: isize,
    ) -> cxx_result_status_code_system_monad;
}
#[doc = "! \\brief Convenience typedef"]
pub type monad_c_result = cxx_result_status_code_system_monad;
unsafe extern "C" {
    #[doc = "! \\brief Return a successful `monad_c_result` for a given `intptr_t`"]
    pub fn monad_c_make_success(v: isize) -> monad_c_result;
}
unsafe extern "C" {
    #[doc = "! \\brief Return a failure `monad_c_result` for a given `errno`"]
    pub fn monad_c_make_failure(ec: ::std::os::raw::c_int) -> monad_c_result;
}
pub type atomic_uint = ::std::os::raw::c_uint;
pub type monad_context = *mut monad_context_head;
#[doc = "! \\brief The public attributes of a task"]
#[repr(C)]
pub struct monad_context_task_head {
    #[doc = "! \\brief The body of the task"]
    pub user_code: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut monad_context_task_head) -> monad_c_result,
    >,
    #[doc = "! \\brief Any user defined value"]
    pub user_ptr: *mut ::std::os::raw::c_void,
    #[doc = "! \\brief The context for the running task"]
    pub context: monad_context,
    #[doc = "! \\brief Set to the result of the task on exit; also used as scratch\n! during the task's suspend-resume cycles"]
    pub result: monad_c_result,
    #[doc = "! \\brief Set by the task implementation to a task detach implementation"]
    pub detach: ::std::option::Option<unsafe extern "C" fn(task: *mut monad_context_task_head)>,
}
impl Default for monad_context_task_head {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "! \\brief The public attributes of a task"]
pub type monad_context_task = *mut monad_context_task_head;
#[doc = "! \\brief Attributes by which to construct a task"]
#[repr(C)]
#[derive(Debug, Default)]
pub struct monad_context_task_attr {
    #[doc = "! \\brief 0 chooses platform default stack size"]
    pub stack_size: usize,
}
#[repr(C)]
#[derive(Debug)]
pub struct monad_context_switcher_head {
    pub user_ptr: *mut ::std::os::raw::c_void,
    #[doc = "! The number of contexts existing"]
    pub contexts: atomic_uint,
    #[doc = "! \\brief Destroys self"]
    pub self_destroy: ::std::option::Option<
        unsafe extern "C" fn(switcher: *mut monad_context_switcher_head) -> monad_c_result,
    >,
    #[doc = "! \\brief Create a switchable context for a task"]
    pub create: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut monad_context,
            switcher: *mut monad_context_switcher_head,
            task: monad_context_task,
            attr: *const monad_context_task_attr,
        ) -> monad_c_result,
    >,
    #[doc = "! \\brief Destroys a switchable context"]
    pub destroy:
        ::std::option::Option<unsafe extern "C" fn(context: monad_context) -> monad_c_result>,
    #[doc = " \\brief If running within a switchable context, suspend it and call\nresume on the new context via its context switcher.\n\nNote that calling this from the main context will not work, as you will have\nno `current_context`. If in the main context, use `resume_many()` to\nget a suitable `current_context`.\n\nThis call differs from `resume()` by being able to cope with `new_context`\nhaving a different context switcher to the current context. If the\nnew context's switcher could be different from the current context's\nswitcher, you must use this call."]
    pub suspend_and_call_resume: ::std::option::Option<
        unsafe extern "C" fn(current_context: monad_context, new_context: monad_context),
    >,
    #[doc = " \\brief Resume execution of a previously suspended switchable context.\n\nGenerally this should only be called from within `resume_many()`'s\n`resumed()` callback, and not otherwise as you won't know if the new\ncontext's switcher is the same as the current context's.\n`suspend_and_call_resume()` does check if the switchers are identical and/or\nare of the same kind but different instances, and if so will take an\noptimised path."]
    pub resume: ::std::option::Option<
        unsafe extern "C" fn(current_context: monad_context, new_context: monad_context),
    >,
    #[doc = " \\brief To avoid having to set a resumption point per task when resuming\nmany tasks from the central loop of the executor, set a single\nresumption point and call the supplied function every time a task\nresumed within the supplied function suspends. This can be very\nconsiderably more efficient for some types of context switcher.\n\nGenerally you call `resume()` from within `resumed()` as the context\nswitcher of the new context will be `switcher`."]
    pub resume_many: ::std::option::Option<
        unsafe extern "C" fn(
            switcher: *mut monad_context_switcher_head,
            resumed: ::std::option::Option<
                unsafe extern "C" fn(
                    user_ptr: *mut ::std::os::raw::c_void,
                    current_context_to_use_when_resuming: monad_context,
                ) -> monad_c_result,
            >,
            user_ptr: *mut ::std::os::raw::c_void,
        ) -> monad_c_result,
    >,
}
impl Default for monad_context_switcher_head {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type monad_context_switcher = *mut monad_context_switcher_head;
#[repr(C)]
#[derive(Debug, Default)]
pub struct monad_context_switcher_impl {
    #[doc = "! \\brief Create a switcher of contexts. The\n! executor creates one of these per executor."]
    pub create: ::std::option::Option<
        unsafe extern "C" fn(switcher: *mut monad_context_switcher) -> monad_c_result,
    >,
}
#[repr(C)]
pub struct monad_context_head {
    pub is_running: bool,
    pub is_suspended: bool,
    pub switcher: monad_context_switcher,
    pub thread_db_slot: usize,
    pub sanitizer: monad_context_head__bindgen_ty_1,
}
#[repr(C)]
pub struct monad_context_head__bindgen_ty_1 {
    pub __bindgen_anon_1: monad_context_head__bindgen_ty_1__bindgen_ty_1,
    pub bottom: *const ::std::os::raw::c_void,
    pub size: usize,
}
#[repr(C)]
pub struct monad_context_head__bindgen_ty_1__bindgen_ty_1 {
    pub fake_stack_save: __BindgenUnionField<*mut ::std::os::raw::c_void>,
    pub valgrind_stack_id: __BindgenUnionField<::std::os::raw::c_uint>,
    pub fiber: __BindgenUnionField<*mut ::std::os::raw::c_void>,
    pub bindgen_union_field: u64,
}
impl Default for monad_context_head__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for monad_context_head__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for monad_context_head {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    #[doc = "! \\brief For a context currently suspended, change which context switcher to\n! use for the next resumption. Context switchers must be of same type."]
    pub fn monad_context_reparent_switcher(
        context: monad_context,
        new_switcher: monad_context_switcher,
    );
}
unsafe extern "C" {
    #[doc = "! \\brief Destroys any context switcher"]
    pub fn monad_context_switcher_destroy(switcher: monad_context_switcher) -> monad_c_result;
}
unsafe extern "C" {
    #[doc = " \\brief Creates a `setjmp`/`longjmp` based context switcher with each task\ngetting its own stack.\n\nNote that an instance of this is NOT threadsafe, so you must either lock\na mutex around switching contexts using this context switcher or have a\ncontext switcher instance per thread."]
    pub fn monad_context_switcher_sjlj_create(
        switcher: *mut monad_context_switcher,
    ) -> monad_c_result;
}
unsafe extern "C" {
    #[doc = "! \\brief Convenience struct for setting a `setjmp`/`longjmp` based context\n! switcher"]
    pub static monad_context_switcher_sjlj: monad_context_switcher_impl;
}
unsafe extern "C" {
    #[doc = " \\brief Creates a none context switcher which can't suspend-resume. Useful\nfor threadpool implementation.\n\nAs this context switcher never suspends and resumes, it is safe to use a single\ninstance of this across multiple threads. In fact, the current implementation\nalways returns a static instance, and destruction does nothing. You may\ntherefore find `monad_context_switcher_none_instance()` more useful."]
    pub fn monad_context_switcher_none_create(
        switcher: *mut monad_context_switcher,
    ) -> monad_c_result;
}
unsafe extern "C" {
    #[doc = "! \\brief Convenience struct for setting a none context\n! switcher"]
    pub static monad_context_switcher_none: monad_context_switcher_impl;
}
unsafe extern "C" {
    #[doc = "! \\brief Convenience obtainer of the static none context switcher."]
    pub fn monad_context_switcher_none_instance() -> monad_context_switcher;
}
unsafe extern "C" {
    #[doc = " \\brief Creates a `fcontext` based context switcher with each task\ngetting its own stack. This is approx 2x faster than the `setjmp`/`longjmp`\ncontext switcher if in a hot loop\n\nNote that an instance of this is NOT threadsafe, so you must either lock\na mutex around switching contexts using this context switcher or have a\ncontext switcher instance per thread."]
    pub fn monad_context_switcher_fcontext_create(
        switcher: *mut monad_context_switcher,
    ) -> monad_c_result;
}
unsafe extern "C" {
    #[doc = "! \\brief Convenience struct for setting a `fcontext` based context\n! switcher"]
    pub static monad_context_switcher_fcontext: monad_context_switcher_impl;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iovec {
    pub iov_base: *mut ::std::os::raw::c_void,
    pub iov_len: usize,
}
impl Default for iovec {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type socklen_t = __socklen_t;
pub type sa_family_t = ::std::os::raw::c_ushort;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct sockaddr {
    pub sa_family: sa_family_t,
    pub sa_data: [::std::os::raw::c_char; 14usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct msghdr {
    pub msg_name: *mut ::std::os::raw::c_void,
    pub msg_namelen: socklen_t,
    pub msg_iov: *mut iovec,
    pub msg_iovlen: usize,
    pub msg_control: *mut ::std::os::raw::c_void,
    pub msg_controllen: usize,
    pub msg_flags: ::std::os::raw::c_int,
}
impl Default for msghdr {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type __u32 = ::std::os::raw::c_uint;
pub type __u64 = ::std::os::raw::c_ulonglong;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct open_how {
    pub flags: __u64,
    pub mode: __u64,
    pub resolve: __u64,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct io_sqring_offsets {
    pub head: __u32,
    pub tail: __u32,
    pub ring_mask: __u32,
    pub ring_entries: __u32,
    pub flags: __u32,
    pub dropped: __u32,
    pub array: __u32,
    pub resv1: __u32,
    pub user_addr: __u64,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct io_cqring_offsets {
    pub head: __u32,
    pub tail: __u32,
    pub ring_mask: __u32,
    pub ring_entries: __u32,
    pub overflow: __u32,
    pub cqes: __u32,
    pub flags: __u32,
    pub resv1: __u32,
    pub user_addr: __u64,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct io_uring_params {
    pub sq_entries: __u32,
    pub cq_entries: __u32,
    pub flags: __u32,
    pub sq_thread_cpu: __u32,
    pub sq_thread_idle: __u32,
    pub features: __u32,
    pub wq_fd: __u32,
    pub resv: [__u32; 3usize],
    pub sq_off: io_sqring_offsets,
    pub cq_off: io_cqring_offsets,
}
#[doc = "! \\brief A type representing the tick count on the CPU"]
pub type monad_cpu_ticks_count_t = u64;
#[doc = "! \\brief The public attributes of an executor"]
pub type monad_async_executor = *mut monad_async_executor_head;
pub type monad_async_task = *mut monad_async_task_head;
pub const monad_async_priority_monad_async_priority_high: monad_async_priority = 0;
pub const monad_async_priority_monad_async_priority_normal: monad_async_priority = 1;
pub const monad_async_priority_monad_async_priority_low: monad_async_priority = 2;
pub const monad_async_priority_monad_async_priority_max: monad_async_priority = 3;
pub const monad_async_priority_monad_async_priority_unchanged: monad_async_priority = 255;
#[doc = "! \\brief Task priority classes"]
pub type monad_async_priority = ::std::os::raw::c_uchar;
#[doc = "! \\brief An i/o status state used to identify an i/o in progress. Must NOT\n! move in memory until the operation completes."]
#[repr(C)]
pub struct monad_async_io_status {
    pub prev: *mut monad_async_io_status,
    pub next: *mut monad_async_io_status,
    pub cancel_: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: monad_async_task,
            arg2: *mut monad_async_io_status,
            arg3: bool,
        ) -> monad_c_result,
    >,
    pub __bindgen_anon_1: monad_async_io_status__bindgen_ty_1,
    pub ticks_when_initiated: monad_cpu_ticks_count_t,
    pub ticks_when_completed: monad_cpu_ticks_count_t,
    pub ticks_when_reaped: monad_cpu_ticks_count_t,
}
#[repr(C)]
pub struct monad_async_io_status__bindgen_ty_1 {
    #[doc = "! Unspecified value immediately after initiating call returns. Will\n! become bytes transferred if operation is successful, or another\n! error if it fails or is cancelled."]
    pub result: __BindgenUnionField<monad_c_result>,
    pub __bindgen_anon_1: __BindgenUnionField<monad_async_io_status__bindgen_ty_1__bindgen_ty_1>,
    pub bindgen_union_field: [u64; 4usize],
}
#[repr(C)]
#[derive(Debug)]
pub struct monad_async_io_status__bindgen_ty_1__bindgen_ty_1 {
    pub task_: monad_async_task,
    pub tofill_: *mut monad_async_task_registered_io_buffer,
    pub file_or_sock_: *mut ::std::os::raw::c_void,
}
impl Default for monad_async_io_status__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for monad_async_io_status__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for monad_async_io_status {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "! \\brief The public attributes of a task"]
#[repr(C)]
pub struct monad_async_task_head {
    pub derived: monad_context_task_head,
    pub io_recipient_task: *mut monad_async_task_head,
    pub priority: monad_async_task_head__bindgen_ty_1,
    pub current_executor: monad_async_executor,
    pub is_awaiting_dispatch: bool,
    pub is_pending_launch: bool,
    pub is_running: bool,
    pub is_suspended_for_io: bool,
    pub is_suspended_sqe_exhaustion: bool,
    pub is_suspended_sqe_exhaustion_wr: bool,
    pub is_suspended_io_buffer_exhaustion: bool,
    pub is_suspended_max_concurrency: bool,
    pub is_suspended_awaiting: bool,
    pub is_suspended_completed: bool,
    pub ticks_when_submitted: monad_cpu_ticks_count_t,
    pub ticks_when_attached: monad_cpu_ticks_count_t,
    pub ticks_when_detached: monad_cpu_ticks_count_t,
    pub ticks_when_suspended_awaiting: monad_cpu_ticks_count_t,
    pub ticks_when_suspended_completed: monad_cpu_ticks_count_t,
    pub ticks_when_resumed: monad_cpu_ticks_count_t,
    pub total_ticks_executed: monad_cpu_ticks_count_t,
    pub io_submitted: ::std::os::raw::c_uint,
    pub io_completed_not_reaped: ::std::os::raw::c_uint,
}
#[repr(C)]
#[derive(Debug)]
pub struct monad_async_task_head__bindgen_ty_1 {
    pub cpu: monad_async_priority,
    pub io: monad_async_priority,
}
impl Default for monad_async_task_head__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for monad_async_task_head {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "! \\brief Attributes by which to construct a task"]
#[repr(C)]
#[derive(Debug, Default)]
pub struct monad_async_task_attr {
    pub derived: monad_context_task_attr,
}
unsafe extern "C" {
    #[doc = "! \\brief EXPENSIVE Creates a task instance using the specified context\n! switcher."]
    pub fn monad_async_task_create(
        task: *mut monad_async_task,
        switcher: monad_context_switcher,
        attr: *mut monad_async_task_attr,
    ) -> monad_c_result;
}
unsafe extern "C" {
    #[doc = "! \\brief EXPENSIVE Destroys a task instance. If the task is currently\n! suspended, it will be cancelled first in which case `EAGAIN` may be returned\n! from this function until cancellation succeeds."]
    pub fn monad_async_task_destroy(task: monad_async_task) -> monad_c_result;
}
unsafe extern "C" {
    #[doc = "! \\brief Check that the task's metadata matches the lists it is in etc."]
    pub fn monad_async_task_debug_validate(task: monad_async_task);
}
unsafe extern "C" {
    #[doc = " \\brief Initiate the transfer of a task's context's execution to a different\ntype of executor.\n\nThis function suspends the execution of the task and requests its executor to\noptionally take a copy of the public information of the task into `opt_save` so\nit can be restored later (this preserves tick counts etc), detach the task from\nthe executor, and then invoke the supplied function with the now 'naked' task.\nAnother type of executor may then overwrite the bytes after `monad_context_task`\nup to `MONAD_CONTEXT_TASK_ALLOCATION_SIZE`. If you need to pass your `to_invoke`\nadditional state, remember there is a `user_ptr` in `monad_context_task`.\n\nRemember that when the context resumes execution in the new executor, anything\nrelated to `monad_async_*` no longer applies. You can choose the return value of\nthis function by setting `task->head.derived.result` before resuming the\ncontext.\n\nIf your context wishes to return to this executor later, consider using\n`monad_async_task_from_foreign_context()` followed by\n`monad_async_task_attach()`."]
    pub fn monad_async_task_suspend_save_detach_and_invoke(
        task: monad_async_task,
        opt_save: monad_async_task,
        to_invoke: ::std::option::Option<
            unsafe extern "C" fn(detached_task: monad_context_task) -> monad_c_result,
        >,
    ) -> monad_c_result;
}
unsafe extern "C" {
    #[doc = "! \\brief Optionally copies the `monad_async_*` parts of `opt_save` into\n! `context_task`, and returns it as a `monad_async_task`."]
    pub fn monad_async_task_from_foreign_context(
        context_task: monad_context_task,
        opt_save: monad_async_task,
    ) -> monad_async_task;
}
unsafe extern "C" {
    #[doc = "! \\brief THREADSAFE Attaches a task instance onto a given executor, which\n! means it will launch the next time the executor runs. If the task is\n! attached already to a different executor, you MUST call this function from\n! that executor's kernel thread. If you optionally choose to reparent the\n! task's context to a new context switcher instance (typical if attaching\n! to an executor on a different kernel thread), it MUST be the same type of\n! context switcher."]
    pub fn monad_async_task_attach(
        executor: monad_async_executor,
        task: monad_async_task,
        opt_reparent_switcher: monad_context_switcher,
    ) -> monad_c_result;
}
unsafe extern "C" {
    #[doc = "! \\brief THREADSAFE If a task is currently suspended on an operation, cancel\n! it. This can take some time for the relevant io_uring operation to also\n! cancel. If the task is yet to launch, don't launch it. If the task isn't\n! currently running, do nothing. The suspension point will return\n! `ECANCELED` next time the cancelled task resumes."]
    pub fn monad_async_task_cancel(
        executor: monad_async_executor,
        task: monad_async_task,
    ) -> monad_c_result;
}
unsafe extern "C" {
    #[doc = "! \\brief Change the CPU or i/o priority of a task"]
    pub fn monad_async_task_set_priorities(
        task: monad_async_task,
        cpu: monad_async_priority,
        io: monad_async_priority,
    ) -> monad_c_result;
}
unsafe extern "C" {
    #[doc = "! \\brief Ask io_uring to cancel a previously initiated operation. It can take\n! some time for io_uring to cancel an operation, and it may ignore your\n! request."]
    pub fn monad_async_task_io_cancel(
        task: monad_async_task,
        iostatus: *mut monad_async_io_status,
    ) -> monad_c_result;
}
unsafe extern "C" {
    #[doc = "! \\brief Iterate through completed i/o for this task, reaping each from the\n! completed but not reaped list."]
    pub fn monad_async_task_completed_io(task: monad_async_task) -> *mut monad_async_io_status;
}
unsafe extern "C" {
    #[doc = "! \\brief Non-cancellable infinity duration"]
    pub static monad_async_duration_infinite_non_cancelling: u64;
}
#[doc = "! \\brief Cancellable infinity duration"]
pub const monad_async_duration_infinite_cancelling: u64 = 31536000000000000;
unsafe extern "C" {
    #[doc = " \\brief OPTIONAL CANCELLATION POINT Suspend execution of a task for a given\nduration, which can be zero (which equates \"yield\"). If `completed` is not\nnull, if any i/o which the task has initiated completes during the\nsuspension, resume the task setting `completed` to which i/o has just\ncompleted. This i/o is NOT REAPED, you must separately call\n`monad_async_task_completed_io()` to reap that i/o.\n\nIf `ns` is the special duration `monad_async_duration_infinite_non_cancelling`,\nthat makes this function (and all those based upon it) not a cancellation\npoint. This lets you tear down any initiated i/o etc before exiting your task.\nIf you want infinity but it should be a cancellation point, use\n`monad_async_duration_infinite_cancelling`."]
    pub fn monad_async_task_suspend_for_duration(
        completed: *mut *mut monad_async_io_status,
        task: monad_async_task,
        ns: u64,
    ) -> monad_c_result;
}
#[doc = "! \\brief A registered i/o buffer"]
#[repr(C)]
#[derive(Debug)]
pub struct monad_async_task_registered_io_buffer {
    pub index: ::std::os::raw::c_int,
    pub iov: [iovec; 1usize],
}
impl Default for monad_async_task_registered_io_buffer {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "! \\brief Flags for claiming a registered i/o buffer"]
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default)]
pub struct monad_async_task_claim_registered_io_buffer_flags {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
impl monad_async_task_claim_registered_io_buffer_flags {
    #[inline]
    pub fn fail_dont_suspend(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_fail_dont_suspend(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn fail_dont_suspend_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_fail_dont_suspend_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn _for_read_ring(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set__for_read_ring(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn _for_read_ring_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set__for_read_ring_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        fail_dont_suspend: ::std::os::raw::c_uint,
        _for_read_ring: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let fail_dont_suspend: u32 = unsafe { ::std::mem::transmute(fail_dont_suspend) };
            fail_dont_suspend as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let _for_read_ring: u32 = unsafe { ::std::mem::transmute(_for_read_ring) };
            _for_read_ring as u64
        });
        __bindgen_bitfield_unit
    }
}
unsafe extern "C" {
    #[doc = " \\brief CANCELLATION POINT Claim an unused registered **write** buffer for\nfile i/o, suspending if none currently available unless the `fail_dont_suspend`\nflag is set.\n\nThere are two sizes of registered i/o write buffer, small and large which are\nthe page size of the host platform (e.g. 4Kb and 2Mb if on Intel x64). Through\nbeing always whole page sizes, DMA using registered i/o buffers has the lowest\npossible overhead.\n\nIt is important to note that these buffers can ONLY be used for write operations\non the write ring. For read operations, it is io_uring which allocates the\nbuffers.\n\nBecause it is you the user who claims write buffers, it is on you to detect\nand avoid write buffer deadlock where that might occur. Generally, you should\nallocate more write buffers than extant write i/o could ever occur, but if\nthat isn't feasible then you ought to set the `fail_dont_suspend` flag and\nthen either schedule the write i/o for later, or use a non-registered buffer,\nor some other strategy. The error returned will be equivalent to `ENOBUFS`."]
    pub fn monad_async_task_claim_registered_file_io_write_buffer(
        buffer: *mut monad_async_task_registered_io_buffer,
        task: monad_async_task,
        bytes_requested: usize,
        flags: monad_async_task_claim_registered_io_buffer_flags,
    ) -> monad_c_result;
}
unsafe extern "C" {
    #[doc = " \\brief CANCELLATION POINT Claim an unused registered **write** buffer for\nsocket i/o, suspending if none currently available unless the\n`fail_dont_suspend` flag is set.\n\nThere are two sizes of registered i/o write buffer, small and large which are\nthe page size of the host platform (e.g. 4Kb and 2Mb if on Intel x64). Through\nbeing always whole page sizes, DMA using registered i/o buffers has the lowest\npossible overhead.\n\nIt is important to note that these buffers can ONLY be used for write operations\non the write ring. For read operations, it is io_uring which allocates the\nbuffers.\n\nBecause it is you the user who claims write buffers, it is on you to detect\nand avoid write buffer deadlock where that might occur. Generally, you should\nallocate more buffers than extant i/o could ever occur (as for socket i/o, read\nand write buffers come from the same pool), but if that isn't feasible then you\nought to set the `fail_dont_suspend` flag and then either schedule the write i/o\nfor later, or use a non-registered buffer, or some other strategy. The error\nreturned will be equivalent to `ENOBUFS`."]
    pub fn monad_async_task_claim_registered_socket_io_write_buffer(
        buffer: *mut monad_async_task_registered_io_buffer,
        task: monad_async_task,
        bytes_requested: usize,
        flags: monad_async_task_claim_registered_io_buffer_flags,
    ) -> monad_c_result;
}
unsafe extern "C" {
    #[doc = " \\brief Release a previously claimed registered buffer.\n\nYou must claim write i/o buffers using\n`monad_async_task_claim_registered_file_io_write_buffer()` or\n`monad_async_task_claim_registered_socket_io_write_buffer()`. Read i/o buffers\nare allocated by io_uring, you release them after use using this function."]
    pub fn monad_async_task_release_registered_io_buffer(
        task: monad_async_task,
        buffer_index: ::std::os::raw::c_int,
    ) -> monad_c_result;
}
#[doc = "! \\brief The public attributes of an executor"]
#[repr(C)]
#[derive(Debug)]
pub struct monad_async_executor_head {
    pub current_task: monad_async_task,
    pub tasks_pending_launch: usize,
    pub tasks_running: usize,
    pub tasks_suspended_sqe_exhaustion: usize,
    pub tasks_suspended: usize,
    pub total_ticks_in_run: monad_cpu_ticks_count_t,
    pub total_ticks_in_task_launch: monad_cpu_ticks_count_t,
    pub total_ticks_in_io_uring: monad_cpu_ticks_count_t,
    pub total_ticks_sleeping: monad_cpu_ticks_count_t,
    pub total_ticks_in_task_completion: monad_cpu_ticks_count_t,
    pub total_io_submitted: u64,
    pub total_io_completed: u64,
    pub registered_buffers: monad_async_executor_head__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct monad_async_executor_head__bindgen_ty_1 {
    pub total_claimed: u64,
    pub total_released: u64,
    pub total_deadlocks_broken: u64,
    pub ticks_last_claim: monad_cpu_ticks_count_t,
    pub ticks_last_release: monad_cpu_ticks_count_t,
}
impl Default for monad_async_executor_head {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "! \\brief Attributes by which to construct an executor"]
#[repr(C)]
#[derive(Debug, Default)]
pub struct monad_async_executor_attr {
    pub io_uring_ring: monad_async_executor_attr__bindgen_ty_1,
    pub io_uring_wr_ring: monad_async_executor_attr__bindgen_ty_1,
    #[doc = " \\brief For file i/o, the maximum concurrent read or write ops is\nconstrained by registered i/o buffers available. However, as i/o\nbuffers remain in use for a while, one may wish to reduce max i/o\nconcurrency still further.\n\nThe kernel considerably gates i/o concurrency on its own, however\nit has been benchmarked that io_uring appears to not scale well\nto outstanding i/o (I think it uses linear lists). So for highly\nbursty concurrent i/o loads, gating i/o concurrency in user space\ncan prove to be an overall win.\n\nYou should benchmark turning this on, as it does add a fair bit of\noverhead so it can be an overall loss as well as a win.\n\nIf enabled, this will ensure that `total_io_submitted - total_io_completed\n<= max_io_concurrency`."]
    pub max_io_concurrency: ::std::os::raw::c_uint,
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct monad_async_executor_attr__bindgen_ty_1 {
    #[doc = " \\brief If this is zero, this executor will be incapable of doing\ni/o! It also no longer initialises io_uring for this executor.\n\nInitiating more i/o than there are io_uring entries is inefficient as it\nwill cause initiating tasks to be suspended and resumed when more\nio_uring entries appear. The overhead isn't as bad as running out of\nregistered i/o buffers which you should avoid where possible."]
    pub entries: ::std::os::raw::c_uint,
    #[doc = "! \\brief The parameters to give to io_uring during ring\n! construction."]
    pub params: io_uring_params,
    pub registered_buffers: monad_async_executor_attr__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct monad_async_executor_attr__bindgen_ty_1__bindgen_ty_1 {
    #[doc = " \\brief How many small and large buffers to register.\n\nBe aware that running out of registered i/o buffers causes execution\nof a slow code path, and can cause execution of a **very** slow code\npath in rare occasions. You should endeavour to never run out of i/o\nbuffers, constraining how much i/o you initiate instead (see\n`max_io_concurrency` below)."]
    pub small_count: ::std::os::raw::c_uint,
    #[doc = " \\brief How many small and large buffers to register.\n\nBe aware that running out of registered i/o buffers causes execution\nof a slow code path, and can cause execution of a **very** slow code\npath in rare occasions. You should endeavour to never run out of i/o\nbuffers, constraining how much i/o you initiate instead (see\n`max_io_concurrency` below)."]
    pub large_count: ::std::os::raw::c_uint,
    #[doc = "! \\brief How many of each of small pages and of large pages the\n! small and large buffer sizes are."]
    pub small_multiplier: ::std::os::raw::c_uint,
    #[doc = "! \\brief How many of each of small pages and of large pages the\n! small and large buffer sizes are."]
    pub large_multiplier: ::std::os::raw::c_uint,
    #[doc = " \\brief Number of small and large buffers to have io_uring\nallocate during read operations.\n\nio_uring can allocate i/o buffers at the point of successful read\nwhich is obviously much more efficient than userspace allocating\nread i/o buffers prior to initiating the read, which ties up i/o\nbuffers. However, socket i/o doesn't use the write ring, so if all\nbuffers are allocated for read then you would have no buffers for\nwriting to sockets. Therefore you may want some of the buffers\navailable for userspace allocation, and some for kernel allocation\ndepending on use case.\n\nA further complication is that if you enable this facility, if\nio_uring receives i/o and no buffers remain available to it, it\nwill fail the read i/o with a result equivalent to `ENOBUFS`. It\nis 100% on you to free up some buffers and reschedule the read if\nthis occurs. io_uring is much keener to return `ENOBUFS` than if\nyou don't use this facility where we use a timeout to detect i/o\nbuffer deadlock, and we only issue `ENOBUFS` in that circumstance\nonly."]
    pub small_kernel_allocated_count: ::std::os::raw::c_uint,
    #[doc = " \\brief Number of small and large buffers to have io_uring\nallocate during read operations.\n\nio_uring can allocate i/o buffers at the point of successful read\nwhich is obviously much more efficient than userspace allocating\nread i/o buffers prior to initiating the read, which ties up i/o\nbuffers. However, socket i/o doesn't use the write ring, so if all\nbuffers are allocated for read then you would have no buffers for\nwriting to sockets. Therefore you may want some of the buffers\navailable for userspace allocation, and some for kernel allocation\ndepending on use case.\n\nA further complication is that if you enable this facility, if\nio_uring receives i/o and no buffers remain available to it, it\nwill fail the read i/o with a result equivalent to `ENOBUFS`. It\nis 100% on you to free up some buffers and reschedule the read if\nthis occurs. io_uring is much keener to return `ENOBUFS` than if\nyou don't use this facility where we use a timeout to detect i/o\nbuffer deadlock, and we only issue `ENOBUFS` in that circumstance\nonly."]
    pub large_kernel_allocated_count: ::std::os::raw::c_uint,
}
unsafe extern "C" {
    #[doc = " \\brief EXPENSIVE Creates an executor instance. You must create it on the\nkernel thread where it will be used.\n\nGenerally, one also needs to create context switcher instances for each\nexecutor instance. This is because the context switcher needs to store how\nto resume the executor when a task's execution suspends.\n\nYou can optionally create an io_uring instance for the executor by setting\n`attr->io_uring_ring.entries` to non-zero. This will then be used to dispatch\nwork instead of an internal dispatcher.\n\nYou may additionally optionally create a second io_uring instance called\n\"write ring\" by setting `attr->io_uring_wr_ring.entries` to non-zero. This\nis mandatory if you wish to write to files, otherwise it is not used.\n\nThe reason a special io_uring instance is used for operations which modify\nfiles is because a total sequentially consistent order is applied to all file\nwrite operations. This implements a \"multi-copy atomic\" memory model similar\nto that used by ARM microprocessors. This is a weak memory model, but one\nsufficient to prevent:\n\n1. Write amplification on the device caused by multiple concurrent writes.\n\n2. Writes appearing to readers not in the order of write submission.\n\nThe most efficient way of implementing this weak memory model is a specially\nconfigured io_uring instance, so this is why we have that.\n\nDo NOT use the \"write ring\" for writes to sockets, it will severely impact\nperformance!"]
    pub fn monad_async_executor_create(
        ex: *mut monad_async_executor,
        attr: *mut monad_async_executor_attr,
    ) -> monad_c_result;
}
unsafe extern "C" {
    #[doc = "! \\brief EXPENSIVE Destroys an executor instance."]
    pub fn monad_async_executor_destroy(ex: monad_async_executor) -> monad_c_result;
}
unsafe extern "C" {
    #[doc = " \\brief Processes no more than `max_items` work items, returning the number\nof items processed. A null `timeout` means wait forever, and a zero timeout will\npoll without blocking.\n\nNote that this function is particularly prone to early return i.e. partly\nor entirely ignoring timeout. Causes can include being woken externally by\n`monad_async_executor_wake()`, there being write i/o pending (as then two\nrings need to be checked), and the usual spurious early timeouts from Linux.\nIf you do complex processing around calling this function, it may be wise\nto only do that processing if the value returned is not zero."]
    pub fn monad_async_executor_run(
        ex: monad_async_executor,
        max_items: usize,
        timeout: *const timespec,
    ) -> monad_c_result;
}
unsafe extern "C" {
    #[doc = "! \\brief THREADSAFE Causes a sleeping executor to wake. Can be called from any\n! kernel thread. `cause_run_to_return` causes `monad_async_executor_run()` to\n! return the result given, otherwise the internal sleep wakes, executor state\n! is examined for new work and the sleep reestablished WHICH MAY NOT CAUSE RUN\n! TO RETURN."]
    pub fn monad_async_executor_wake(
        ex: monad_async_executor,
        cause_run_to_return: *const monad_c_result,
    ) -> monad_c_result;
}
unsafe extern "C" {
    #[doc = " \\brief If new i/o submitted since the last run exceeds\n`max_items_in_submission_queue`, invoke io_uring submit now. If submission now\noccurs, a positive successful result is returned, otherwise zero."]
    pub fn monad_async_executor_submit(
        ex: monad_async_executor,
        max_items_in_nonwrite_submission_queue: usize,
        max_items_in_write_submission_queue: usize,
    ) -> monad_c_result;
}
unsafe extern "C" {
    #[doc = " \\brief Return a pointer (as `intptr_t`) to a null terminated string\ndescribing the configuration of this executor. This lets you see what io_uring\nfeatures were detected, as well as versions and other config.\n\n\\warning You need to call `free()` on the pointer when you are done with it."]
    pub fn monad_async_executor_config_string(ex: monad_async_executor) -> monad_c_result;
}
unsafe extern "C" {
    #[doc = " \\brief Return a pointer (as `intptr_t`) to a null terminated string\ndescribing the internal state of this executor. This is useful for debugging the\nexecutor if it goes wrong e.g. hangs.\n\n\\warning You need to call `free()` on the pointer when you are done with it."]
    pub fn monad_async_executor_debug_string(ex: monad_async_executor) -> monad_c_result;
}
#[doc = "! \\brief An offset into a file"]
pub type monad_async_file_offset = u64;
#[doc = "! \\brief The public attributes of an open file"]
#[repr(C)]
#[derive(Debug)]
pub struct monad_async_file_head {
    pub executor: *mut monad_async_executor_head,
    pub total_io_submitted: u32,
    pub total_io_completed: u32,
}
impl Default for monad_async_file_head {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "! \\brief The public attributes of an open file"]
pub type monad_async_file = *mut monad_async_file_head;
unsafe extern "C" {
    #[doc = " \\brief EXPENSIVE, CANCELLATION POINT Suspend execution of the task until the\nfile has been opened. See `man open2` to explain parameters.\n\nThis is a relatively expensive operation as it may do up to two mallocs and\nseveral syscalls per call."]
    pub fn monad_async_task_file_create(
        file: *mut monad_async_file,
        task: monad_async_task,
        base: monad_async_file,
        subpath: *const ::std::os::raw::c_char,
        how: *mut open_how,
    ) -> monad_c_result;
}
unsafe extern "C" {
    #[doc = " \\brief EXPENSIVE, CANCELLATION POINT Suspend execution of the task until the\nuserspace file descriptor has been registered with io_uring and a file instance\nrepresenting it returned.\n\nThis function is provided purely for bridging this to legacy code -- wherever\npossible you should use the native file and socket creation functions as\nthese completely bypass userspace and don't create any of the problems POSIX\nfile descriptors do."]
    pub fn monad_async_task_file_create_from_existing_fd(
        file: *mut monad_async_file,
        task: monad_async_task,
        fd: ::std::os::raw::c_int,
    ) -> monad_c_result;
}
unsafe extern "C" {
    #[doc = "! \\brief Suspend execution of the task until the file has been closed"]
    pub fn monad_async_task_file_destroy(
        task: monad_async_task,
        file: monad_async_file,
    ) -> monad_c_result;
}
unsafe extern "C" {
    #[doc = "! \\brief CANCELLATION POINT Suspend execution of the task until the file's\n! valid extents have been modified as per the `fallocate` call, see `man\n! fallocate` for more."]
    pub fn monad_async_task_file_fallocate(
        task: monad_async_task,
        file: monad_async_file,
        mode: ::std::os::raw::c_int,
        offset: monad_async_file_offset,
        len: monad_async_file_offset,
    ) -> monad_c_result;
}
unsafe extern "C" {
    #[doc = " \\brief CANCELLATION POINT Initiate a ring buffer read from an open file\nusing `iostatus` as the identifier.\n\nReturns immediately unless there are no free io_uring submission entries.\nSee `man readv2` to explain parameters. The i/o priority used will be that\nfrom the task's current i/o priority setting.\n\nUpon completion, `tofill->iovecs[0]` will be the buffer filled with up to\n`max_bytes` (though it can be less). When you are done with the buffer, release\nit back to io_uring using `monad_async_task_release_registered_io_buffer()`.\nLack of i/o buffers will cause suspension of the calling task until i/o\nbuffers are released. If the lack of i/o buffers across all tasks would cause\ndeadlock, it is possible for an i/o to complete with failure comparing\nequivalent to `ENOBUFS`, in which case you should retry the operation.\n\n`max_bytes` chooses whether to use large or small page sized buffers and the\nactual bytes read does not affect the size of buffer chosen.\n\nCancellation, or any other error, is reflected by the i/o status becoming\nimmediately completed with the error."]
    pub fn monad_async_task_file_read(
        iostatus: *mut monad_async_io_status,
        task: monad_async_task,
        file: monad_async_file,
        tofill: *mut monad_async_task_registered_io_buffer,
        max_bytes: usize,
        offset: monad_async_file_offset,
        flags: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " \\brief CANCELLATION POINT Initiate a scatter read from an open file using\n`iostatus` as the identifier.\n\nReturns immediately unless there are no free io_uring submission entries.\nSee `man readv2` to explain parameters. The i/o priority used will be that\nfrom the task's current i/o priority setting.\n\n\\warning io_uring **requires** that the contents of iovecs have lifetime until\nthe read completes. The only exception here is if `nr_vecs` is one.\n\nCancellation, or any other error, is reflected by the i/o status becoming\nimmediately completed with the error."]
    pub fn monad_async_task_file_readv(
        iostatus: *mut monad_async_io_status,
        task: monad_async_task,
        file: monad_async_file,
        iovecs: *const iovec,
        nr_vecs: ::std::os::raw::c_uint,
        offset: monad_async_file_offset,
        flags: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " \\brief CANCELLATION POINT Initiate a write to an open file using `iostatus`\nas the identifier.\n\nReturns immediately unless there are no free io_uring submission entries.\nSee `man writev2` to explain parameters. The i/o priority used will be that\nfrom the task's current i/o priority setting.\n\n\\warning io_uring **requires** that the contents of iovecs have lifetime until\nthe writes completes. The only exception here is if `nr_vecs` is one.\n\nCancellation, or any other error, is reflected by the i/o status becoming\nimmediately completed with the error."]
    pub fn monad_async_task_file_write(
        iostatus: *mut monad_async_io_status,
        task: monad_async_task,
        file: monad_async_file,
        buffer_index: ::std::os::raw::c_int,
        iovecs: *const iovec,
        nr_vecs: ::std::os::raw::c_uint,
        offset: monad_async_file_offset,
        flags: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = "! \\brief CANCELLATION POINT Initiate a flush of dirty file extents using\n! `iostatus` as the identifier. Returns immediately unless there are no free\n! io_uring submission entries. See `man sync_file_range` to explain\n! parameters. The i/o priority used will be that from the task's current i/o\n! priority setting. This is the right call to use to encourage the kernel to\n! flush a region of data now, it is the wrong call to ensure write durability\n! as it neither flushes metadata nor tells the storage device to flush."]
    pub fn monad_async_task_file_range_sync(
        iostatus: *mut monad_async_io_status,
        task: monad_async_task,
        file: monad_async_file,
        offset: monad_async_file_offset,
        bytes: ::std::os::raw::c_uint,
        flags: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = "! \\brief CANCELLATION POINT Initiate a durable sync of an open file using\n! `iostatus` as the identifier. Returns immediately unless there are no free\n! io_uring submission entries. The i/o priority used will be that from the\n! task's current i/o priority setting. This is the right call to use to ensure\n! written data is durably placed onto non-volatile storage.\n!\n! Note that this operation generally takes milliseconds to complete."]
    pub fn monad_async_task_file_durable_sync(
        iostatus: *mut monad_async_io_status,
        task: monad_async_task,
        file: monad_async_file,
    );
}
#[doc = "! \\brief The public attributes of an open socket"]
#[repr(C)]
#[derive(Debug)]
pub struct monad_async_socket_head {
    pub addr: sockaddr,
    pub addr_len: socklen_t,
    pub executor: *mut monad_async_executor_head,
    pub total_io_submitted: u32,
    pub total_io_completed: u32,
}
impl Default for monad_async_socket_head {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "! \\brief The public attributes of an open socket"]
pub type monad_async_socket = *mut monad_async_socket_head;
unsafe extern "C" {
    #[doc = " \\brief EXPENSIVE Create a socket. See `man socket` to explain parameters.\n\nNote that `SO_LINGER` is set to zero to enable hard socket closes. If you want\ndifferent, create your own socket manually and add it to io_uring via\n`monad_async_task_socket_create_from_existing_fd()`.\n\nAt least one malloc is performed, and possibly more."]
    pub fn monad_async_task_socket_create(
        sock: *mut monad_async_socket,
        task: monad_async_task,
        domain: ::std::os::raw::c_int,
        type_: ::std::os::raw::c_int,
        protocol: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_uint,
    ) -> monad_c_result;
}
unsafe extern "C" {
    #[doc = " \\brief EXPENSIVE, CANCELLATION POINT Suspend execution of the task until the\nuserspace file descriptor has been registered with io_uring and a socket\ninstance representing it returned.\n\nThis function is provided purely for bridging this to legacy code -- wherever\npossible you should use the native file and socket creation functions as\nthese completely bypass userspace and don't create any of the problems POSIX\nfile descriptors do."]
    pub fn monad_async_task_socket_create_from_existing_fd(
        sock: *mut monad_async_socket,
        task: monad_async_task,
        fd: ::std::os::raw::c_int,
    ) -> monad_c_result;
}
unsafe extern "C" {
    #[doc = "! \\brief Suspend execution of the task until the socket has been closed"]
    pub fn monad_async_task_socket_destroy(
        task: monad_async_task,
        sock: monad_async_socket,
    ) -> monad_c_result;
}
unsafe extern "C" {
    #[doc = " \\brief EXPENSIVE Bind a socket to an interface and port.\n\nThis is done by blocking syscall, as io_uring is currently incapable of doing\nlistening socket setup by itself."]
    pub fn monad_async_task_socket_bind(
        sock: monad_async_socket,
        addr: *const sockaddr,
        addrlen: socklen_t,
    ) -> monad_c_result;
}
unsafe extern "C" {
    #[doc = " \\brief EXPENSIVE Make a bound socket available for incoming connections.\n\nThis is done by blocking syscall, as io_uring is currently incapable of doing\nlistening socket setup by itself."]
    pub fn monad_async_task_socket_listen(
        sock: monad_async_socket,
        backlog: ::std::os::raw::c_int,
    ) -> monad_c_result;
}
unsafe extern "C" {
    #[doc = " \\brief CANCELLATION POINT Transfers the socket to io_uring, which may\nrequire suspending the task.\n\nAs io_uring is currently incapable of doing listening socket setup by itself,\nthere is an explicit step for transferring the configured socket to io_uring\nas it is an expensive operation.\n\nNewer Linux kernels have an io_uring capable of connecting socket setup and\ncreation entirely within io_uring. If your kernel is so capable, that is used,\nelse blocking syscalls are used and the socket transferred into io_uring.\n\nWhen this call returns, all syscall-created resources are released and io_uring\nexclusively manages the socket."]
    pub fn monad_async_task_socket_transfer_to_uring(
        task: monad_async_task,
        sock: monad_async_socket,
    ) -> monad_c_result;
}
unsafe extern "C" {
    #[doc = " \\brief CANCELLATION POINT Suspend execution of the task if there is no\npending connection on the socket until there is a new connection. See `man\naccept4` to explain parameters.\n\nNote that `SO_LINGER` is set to zero to enable hard socket closes, which you\ngenerally want as a server.\n\nNote that if `SOCK_CLOEXEC` is set in the flags, io_uring will fail the request\n(this is non-obvious, cost me half a day of debugging, so I document it here)"]
    pub fn monad_async_task_socket_accept(
        connected_sock: *mut monad_async_socket,
        task: monad_async_task,
        listening_sock: monad_async_socket,
        flags: ::std::os::raw::c_int,
    ) -> monad_c_result;
}
unsafe extern "C" {
    #[doc = " \\brief CANCELLATION POINT Initiate the connection of an open socket using\n`iostatus` as the identifier.\n\nReturns immediately unless there are no free io_uring submission entries.\nSee `man connect` to explain parameters. The i/o priority used will be that\nfrom the task's current i/o priority setting.\n\nCancellation, or any other error, is reflected by the i/o status becoming\nimmediately completed with the error."]
    pub fn monad_async_task_socket_connect(
        iostatus: *mut monad_async_io_status,
        task: monad_async_task,
        sock: monad_async_socket,
        addr: *const sockaddr,
        addrlen: socklen_t,
    );
}
unsafe extern "C" {
    #[doc = " \\brief CANCELLATION POINT Initiate a shutdown of an open socket using\n`iostatus` as the identifier.\n\nReturns immediately unless there are no free io_uring submission entries.\nSee `man shutdown` to explain parameters. The i/o priority used will be that\nfrom the task's current i/o priority setting.\n\nCancellation, or any other error, is reflected by the i/o status becoming\nimmediately completed with the error."]
    pub fn monad_async_task_socket_shutdown(
        iostatus: *mut monad_async_io_status,
        task: monad_async_task,
        sock: monad_async_socket,
        how: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " \\brief CANCELLATION POINT Initiate a kernel allocated buffer read from an\nopen socket using `iostatus` as the identifier.\n\nReturns immediately unless there are no free io_uring submission entries.\nSee `man recvmsg` to explain parameters. The i/o priority used will be that\nfrom the task's current i/o priority setting.\n\nIf the executor was so configured, this API has io_uring allocate the buffer\nwhich is more efficient than the application saying which buffer to fill. Upon\ncompletion, `tofill->iovecs[0]` will be the buffer filled with up to `max_bytes`\n(though it can be less). When you are done with the buffer, release it back to\nio_uring using `monad_async_task_release_registered_io_buffer()`.\nIf this operation gets a result failure comparing equivalent to `ENOBUFS`,\nthen io_uring ran out of buffers to allocate. You should increase\n`small_kernel_allocated_count` et al in `struct monad_async_executor_attr`.\n\nIf the executor was not configured with `small_kernel_allocated_count` et al,\nthen lack of i/o buffers will cause suspension of the calling task until i/o\nbuffers are released. You must still release buffers filled back to\nio_uring using `monad_async_task_release_registered_io_buffer()`. You can still\nreceive a result failure comparing equivalent to `ENOBUFS` if the executor\nwould hang otherwise.\n\n`max_bytes` chooses whether to use large or small page sized buffers and the\nactual bytes read does not affect the size of buffer chosen.\n\n\\warning io_uring **requires** that the contents of `tofill` and everything it\npoints at have lifetime until the read completes.\n\nCancellation, or any other error, is reflected by the i/o status becoming\nimmediately completed with the error."]
    pub fn monad_async_task_socket_receive(
        iostatus: *mut monad_async_io_status,
        task: monad_async_task,
        sock: monad_async_socket,
        tofill: *mut monad_async_task_registered_io_buffer,
        max_bytes: usize,
        flags: ::std::os::raw::c_uint,
    );
}
unsafe extern "C" {
    #[doc = " \\brief CANCELLATION POINT Initiate a scatter read from an open socket using\n`iostatus` as the identifier.\n\nReturns immediately unless there are no free io_uring submission entries.\nSee `man recvmsg` to explain parameters. The i/o priority used will be that\nfrom the task's current i/o priority setting.\n\n\\warning io_uring **requires** that the contents of `msg` and everything it\npoints at have lifetime until the read completes.\n\nCancellation, or any other error, is reflected by the i/o status becoming\nimmediately completed with the error."]
    pub fn monad_async_task_socket_receivev(
        iostatus: *mut monad_async_io_status,
        task: monad_async_task,
        sock: monad_async_socket,
        msg: *mut msghdr,
        flags: ::std::os::raw::c_uint,
    );
}
unsafe extern "C" {
    #[doc = " \\brief CANCELLATION POINT Initiate a write to an open socket using\n`iostatus` as the identifier.\n\nReturns immediately unless there are no free io_uring submission entries.\nSee `man sendmsg` to explain parameters. The i/o priority used will be that\nfrom the task's current i/o priority setting.\n\n\\warning io_uring **requires** that the contents of `msg` and everything it\npoints at have lifetime until the write completes.\n\nCancellation, or any other error, is reflected by the i/o status becoming\nimmediately completed with the error."]
    pub fn monad_async_task_socket_send(
        iostatus: *mut monad_async_io_status,
        task: monad_async_task,
        sock: monad_async_socket,
        buffer_index: ::std::os::raw::c_int,
        msg: *const msghdr,
        flags: ::std::os::raw::c_uint,
    );
}
#[doc = "! \\brief The public attributes of a work dispatcher"]
#[repr(C)]
#[derive(Debug, Default)]
pub struct monad_async_work_dispatcher_head {
    pub executors: monad_async_work_dispatcher_head__bindgen_ty_1,
    pub tasks_awaiting_dispatch: usize,
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct monad_async_work_dispatcher_head__bindgen_ty_1 {
    pub working: ::std::os::raw::c_uint,
    pub idle: ::std::os::raw::c_uint,
}
#[doc = "! \\brief The public attributes of a work dispatcher"]
pub type monad_async_work_dispatcher = *mut monad_async_work_dispatcher_head;
#[doc = "! \\brief The public attributes of a work dispatcher"]
#[repr(C)]
#[derive(Debug)]
pub struct monad_async_work_dispatcher_executor_head {
    pub derived: *mut monad_async_executor_head,
    pub dispatcher: *mut monad_async_work_dispatcher_head,
    pub is_working: bool,
    pub is_idle: bool,
}
impl Default for monad_async_work_dispatcher_executor_head {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "! \\brief The public attributes of a work dispatcher"]
pub type monad_async_work_dispatcher_executor = *mut monad_async_work_dispatcher_executor_head;
#[doc = "! \\brief Attributes by which to construct a work dispatcher"]
#[repr(C)]
#[derive(Debug, Default)]
pub struct monad_async_work_dispatcher_attr {
    #[doc = "! Dispatcher executors should spin the CPU for this many milliseconds\n! before sleeping"]
    pub spin_before_sleep_ms: u32,
}
#[doc = "! \\brief Attributes by which to construct a work dispatcher"]
#[repr(C)]
#[derive(Debug, Default)]
pub struct monad_async_work_dispatcher_executor_attr {
    pub derived: monad_async_executor_attr,
}
unsafe extern "C" {
    #[doc = "! \\brief EXPENSIVE Creates a work dispatcher instance."]
    pub fn monad_async_work_dispatcher_create(
        dp: *mut monad_async_work_dispatcher,
        attr: *mut monad_async_work_dispatcher_attr,
    ) -> monad_c_result;
}
unsafe extern "C" {
    #[doc = "! \\brief EXPENSIVE Destroys a work dispatcher instance."]
    pub fn monad_async_work_dispatcher_destroy(dp: monad_async_work_dispatcher) -> monad_c_result;
}
unsafe extern "C" {
    #[doc = "! \\brief EXPENSIVE Creates a work dispatcher executor instance."]
    pub fn monad_async_work_dispatcher_executor_create(
        ex: *mut monad_async_work_dispatcher_executor,
        dp: monad_async_work_dispatcher,
        attr: *mut monad_async_work_dispatcher_executor_attr,
    ) -> monad_c_result;
}
unsafe extern "C" {
    #[doc = "! \\brief EXPENSIVE Destroys a work dispatcher executor instance."]
    pub fn monad_async_work_dispatcher_executor_destroy(
        ex: monad_async_work_dispatcher_executor,
    ) -> monad_c_result;
}
unsafe extern "C" {
    #[doc = "! \\brief Calls `monad_async_executor_run()` for the calling kernel thread,\n! attaching tasks recently submitted to kernel threads in the pool with spare\n! capacity as per the work dispatcher's configured policy. Returns the number\n! of work items executed, or -1 when time to exit."]
    pub fn monad_async_work_dispatcher_executor_run(
        ex: monad_async_work_dispatcher_executor,
    ) -> monad_c_result;
}
unsafe extern "C" {
    #[doc = "! \\brief THREADSAFE Causes a sleeping work dispatcher executor to wake. Same\n! as `monad_async_executor_wake()`, but for work dispatcher executors."]
    pub fn monad_async_work_dispatcher_executor_wake(
        ex: monad_async_work_dispatcher_executor,
        cause_run_to_return: *const monad_c_result,
    ) -> monad_c_result;
}
unsafe extern "C" {
    #[doc = "! \\brief THREADSAFE Submits one or more tasks to be executed by the first\n! available executor within the work dispatcher pool. Higher priority tasks\n! are executed before lower priority tasks."]
    pub fn monad_async_work_dispatcher_submit(
        dp: monad_async_work_dispatcher,
        tasks: *mut monad_async_task,
        count: usize,
    ) -> monad_c_result;
}
unsafe extern "C" {
    #[doc = "! \\brief THREADSAFE Wait until all work has been dispatched or executed."]
    pub fn monad_async_work_dispatcher_wait(
        dp: monad_async_work_dispatcher,
        max_undispatched: usize,
        max_unexecuted: usize,
        timeout: *mut timespec,
    ) -> monad_c_result;
}
unsafe extern "C" {
    #[doc = "! \\brief THREADSAFE Tells executors to quit, preferring idle executors first,\n! until no more than `max_executors` remains."]
    pub fn monad_async_work_dispatcher_quit(
        dp: monad_async_work_dispatcher,
        max_executors: usize,
        timeout: *mut timespec,
    ) -> monad_c_result;
}
