/* automatically generated by rust-bindgen 0.66.1 */

pub type fcontext_t = *mut ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct monad_fiber_context {
    pub fiber: fcontext_t,
    pub name: *const ::std::os::raw::c_char,
}
impl Default for monad_fiber_context {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type monad_fiber_context_t = monad_fiber_context;
extern "C" {
    pub fn monad_fiber_main_context() -> *mut monad_fiber_context_t;
}
extern "C" {
    pub fn monad_fiber_set_name(
        arg1: *mut monad_fiber_context_t,
        name: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn monad_fiber_context_switch(
        from: *mut monad_fiber_context_t,
        to: *mut monad_fiber_context_t,
    ) -> *mut monad_fiber_context_t;
}
extern "C" {
    pub fn monad_fiber_context_switch_with(
        from: *mut monad_fiber_context_t,
        to: *mut monad_fiber_context_t,
        func: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut monad_fiber_context_t,
                arg2: *mut ::std::os::raw::c_void,
            ) -> *mut monad_fiber_context_t,
        >,
        arg: *mut ::std::os::raw::c_void,
    ) -> *mut monad_fiber_context_t;
}
pub const monad_fiber_default_stack_size: usize = 131072;
extern "C" {
    pub fn monad_fiber_context_callcc(
        from: *mut monad_fiber_context_t,
        stack_size: usize,
        protected_stack: bool,
        func: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *mut monad_fiber_context_t,
                arg3: *mut monad_fiber_context_t,
            ) -> *mut monad_fiber_context_t,
        >,
        func_arg: *mut ::std::os::raw::c_void,
    ) -> *mut monad_fiber_context_t;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct monad_fiber_task {
    pub resume: ::std::option::Option<unsafe extern "C" fn(arg1: *mut monad_fiber_task)>,
    pub destroy: ::std::option::Option<unsafe extern "C" fn(arg1: *mut monad_fiber_task)>,
}
pub type monad_fiber_task_t = monad_fiber_task;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct monad_fiber_task_node {
    pub task: *mut monad_fiber_task_t,
    pub priority: i64,
}
impl Default for monad_fiber_task_node {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct monad_fiber_task_queue {
    pub memory: *mut monad_fiber_task_node,
    pub capacity: usize,
    pub data: *mut monad_fiber_task_node,
    pub size: usize,
}
impl Default for monad_fiber_task_queue {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type monad_fiber_task_queue_t = monad_fiber_task_queue;
extern "C" {
    pub fn monad_fiber_task_queue_init(arg1: *mut monad_fiber_task_queue);
}
extern "C" {
    pub fn monad_fiber_task_queue_destroy(arg1: *mut monad_fiber_task_queue);
}
extern "C" {
    pub fn monad_fiber_task_queue_grow(arg1: *mut monad_fiber_task_queue);
}
extern "C" {
    pub fn monad_fiber_task_queue_pop_front(
        arg1: *mut monad_fiber_task_queue,
    ) -> monad_fiber_task_node;
}
extern "C" {
    pub fn monad_fiber_task_queue_insert(
        arg1: *mut monad_fiber_task_queue,
        task: *mut monad_fiber_task_t,
        priority: i64,
    );
}
pub type atomic_int = u32;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __atomic_wide_counter {
    pub __value64: ::std::os::raw::c_ulonglong,
    pub __value32: __atomic_wide_counter__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __atomic_wide_counter__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
impl Default for __atomic_wide_counter {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
impl Default for __pthread_internal_list {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_mutex_s {
    pub __lock: ::std::os::raw::c_int,
    pub __count: ::std::os::raw::c_uint,
    pub __owner: ::std::os::raw::c_int,
    pub __nusers: ::std::os::raw::c_uint,
    pub __kind: ::std::os::raw::c_int,
    pub __spins: ::std::os::raw::c_short,
    pub __elision: ::std::os::raw::c_short,
    pub __list: __pthread_list_t,
}
impl Default for __pthread_mutex_s {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_cond_s {
    pub __wseq: __atomic_wide_counter,
    pub __g1_start: __atomic_wide_counter,
    pub __g_refs: [::std::os::raw::c_uint; 2usize],
    pub __g_size: [::std::os::raw::c_uint; 2usize],
    pub __g1_orig_size: ::std::os::raw::c_uint,
    pub __wrefs: ::std::os::raw::c_uint,
    pub __g_signals: [::std::os::raw::c_uint; 2usize],
}
impl Default for __pthread_cond_s {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type pthread_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutex_t {
    pub __data: __pthread_mutex_s,
    pub __size: [::std::os::raw::c_char; 40usize],
    pub __align: ::std::os::raw::c_long,
}
impl Default for pthread_mutex_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_cond_t {
    pub __data: __pthread_cond_s,
    pub __size: [::std::os::raw::c_char; 48usize],
    pub __align: ::std::os::raw::c_longlong,
}
impl Default for pthread_cond_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct monad_fiber_scheduler {
    pub threads: *mut pthread_t,
    pub thread_count: usize,
    pub mutex: pthread_mutex_t,
    pub cond: pthread_cond_t,
    pub task_queue: monad_fiber_task_queue_t,
    pub thread_id_source: atomic_int,
    pub init_thread: ::std::option::Option<unsafe extern "C" fn()>,
}
impl Default for monad_fiber_scheduler {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type monad_fiber_scheduler_t = monad_fiber_scheduler;
extern "C" {
    pub fn monad_fiber_scheduler_current() -> *mut monad_fiber_scheduler_t;
}
extern "C" {
    pub fn monad_fiber_scheduler_work(arg1: *mut monad_fiber_scheduler_t);
}
extern "C" {
    pub fn monad_fiber_scheduler_create(
        arg1: *mut monad_fiber_scheduler_t,
        threads: usize,
        init_thread: ::std::option::Option<unsafe extern "C" fn()>,
    );
}
extern "C" {
    pub fn monad_fiber_scheduler_destroy(arg1: *mut monad_fiber_scheduler_t);
}
extern "C" {
    pub fn monad_fiber_scheduler_stop(arg1: *mut monad_fiber_scheduler_t);
}
extern "C" {
    pub fn monad_fiber_scheduler_post(
        arg1: *mut monad_fiber_scheduler_t,
        task: *mut monad_fiber_task_t,
        priority: i64,
    );
}
extern "C" {
    pub fn monad_fiber_scheduler_dispatch(
        arg1: *mut monad_fiber_scheduler_t,
        task: *mut monad_fiber_task_t,
        priority: i64,
    );
}
extern "C" {
    pub fn monad_fiber_scheduler_pop_higher_priority_task(
        arg1: *mut monad_fiber_scheduler_t,
        priority: i64,
    ) -> *mut monad_fiber_task_t;
}
extern "C" {
    pub fn monad_fiber_run_one(arg1: *mut monad_fiber_scheduler_t) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct monad_fiber {
    pub task: monad_fiber_task_t,
    pub context: *mut monad_fiber_context_t,
    pub priority: i64,
    pub scheduler: *mut monad_fiber_scheduler_t,
}
impl Default for monad_fiber {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type monad_fiber_t = monad_fiber;
extern "C" {
    pub fn monad_fiber_current() -> *mut monad_fiber_t;
}
extern "C" {
    pub fn monad_fiber_is_main(arg1: *mut monad_fiber_t) -> bool;
}
extern "C" {
    pub fn monad_fiber_switch_to_fiber(arg1: *mut monad_fiber_t);
}
extern "C" {
    pub fn monad_fiber_switch_to_main();
}
extern "C" {
    pub fn monad_fiber_init_main();
}
extern "C" {
    pub fn monad_fiber_yield();
}
extern "C" {
    pub fn monad_fiber_activate_fiber(new_current: *mut monad_fiber_t) -> *mut monad_fiber_t;
}
extern "C" {
    pub fn monad_fiber_main() -> *mut monad_fiber_t;
}
extern "C" {
    pub fn monad_fiber_await(
        suspend_to: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut monad_fiber_t, arg2: *mut ::std::os::raw::c_void),
        >,
        arg: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn monad_fiber_create(
        stack_size: usize,
        protected_stack: bool,
        func: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
        arg: *mut ::std::os::raw::c_void,
    ) -> *mut monad_fiber_t;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct monad_fiber_channel {
    pub capacity: usize,
    pub size: usize,
    pub offset: usize,
    pub element_size: usize,
    pub data: *mut ::std::os::raw::c_void,
    pub mutex: pthread_mutex_t,
    pub pending_reads: *mut monad_fiber_channel_read_op,
    pub pending_writes: *mut monad_fiber_channel_write_op,
}
impl Default for monad_fiber_channel {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type monad_fiber_channel_t = monad_fiber_channel;
extern "C" {
    pub fn monad_fiber_channel_create(
        arg1: *mut monad_fiber_channel_t,
        capacity: usize,
        element_size: usize,
    );
}
extern "C" {
    pub fn monad_fiber_channel_destroy(arg1: *mut monad_fiber_channel_t);
}
extern "C" {
    pub fn monad_fiber_channel_try_read(
        arg1: *mut monad_fiber_channel_t,
        target: *mut ::std::os::raw::c_void,
    ) -> bool;
}
extern "C" {
    pub fn monad_fiber_channel_try_write(
        arg1: *mut monad_fiber_channel_t,
        source: *const ::std::os::raw::c_void,
    ) -> bool;
}
extern "C" {
    pub fn monad_fiber_channel_read(
        arg1: *mut monad_fiber_channel_t,
        target: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn monad_fiber_channel_write(
        arg1: *mut monad_fiber_channel_t,
        source: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct monad_fiber_channel_read_op {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct monad_fiber_channel_write_op {
    pub _address: u8,
}
