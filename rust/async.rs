/* automatically generated by rust-bindgen 0.59.1 */

pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __time_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cxx_status_code_system {
    pub domain: *mut ::std::os::raw::c_void,
    pub value: isize,
}
#[test]
fn bindgen_test_layout_cxx_status_code_system() {
    assert_eq!(
        ::std::mem::size_of::<cxx_status_code_system>(),
        16usize,
        concat!("Size of: ", stringify!(cxx_status_code_system))
    );
    assert_eq!(
        ::std::mem::align_of::<cxx_status_code_system>(),
        8usize,
        concat!("Alignment of ", stringify!(cxx_status_code_system))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cxx_status_code_system>())).domain as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cxx_status_code_system),
            "::",
            stringify!(domain)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cxx_status_code_system>())).value as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cxx_status_code_system),
            "::",
            stringify!(value)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cxx_result_status_code_system_monad_async {
    pub value: isize,
    pub flags: ::std::os::raw::c_uint,
    pub error: cxx_status_code_system,
}
#[test]
fn bindgen_test_layout_cxx_result_status_code_system_monad_async() {
    assert_eq!(
        ::std::mem::size_of::<cxx_result_status_code_system_monad_async>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(cxx_result_status_code_system_monad_async)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<cxx_result_status_code_system_monad_async>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(cxx_result_status_code_system_monad_async)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cxx_result_status_code_system_monad_async>())).value as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cxx_result_status_code_system_monad_async),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cxx_result_status_code_system_monad_async>())).flags as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cxx_result_status_code_system_monad_async),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cxx_result_status_code_system_monad_async>())).error as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cxx_result_status_code_system_monad_async),
            "::",
            stringify!(error)
        )
    );
}
#[doc = "! \\brief Convenience typedef"]
pub type monad_async_result = cxx_result_status_code_system_monad_async;
extern "C" {
    #[doc = "! \\brief Return a successful `monad_async_result` for a given `intptr_t`"]
    pub fn monad_async_make_success(v: isize) -> monad_async_result;
}
extern "C" {
    #[doc = "! \\brief Return a failure `monad_async_result` for a given `errno`"]
    pub fn monad_async_make_failure(ec: ::std::os::raw::c_int) -> monad_async_result;
}
#[doc = "! \\brief A type representing the tick count on the CPU"]
pub type monad_async_cpu_ticks_count_t = u64;
pub const monad_async_priority_monad_async_priority_high: monad_async_priority = 0;
pub const monad_async_priority_monad_async_priority_normal: monad_async_priority = 1;
pub const monad_async_priority_monad_async_priority_low: monad_async_priority = 2;
pub const monad_async_priority_monad_async_priority_max: monad_async_priority = 3;
#[doc = "! \\brief Task priority classes"]
pub type monad_async_priority = ::std::os::raw::c_uchar;
pub type size_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[test]
fn bindgen_test_layout_timespec() {
    assert_eq!(
        ::std::mem::size_of::<timespec>(),
        16usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::std::mem::align_of::<timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timespec>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timespec>())).tv_nsec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
pub type monad_async_executor = *mut monad_async_executor_head;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct monad_async_task_head {
    pub priority: monad_async_task_head__bindgen_ty_1,
    pub result: monad_async_result,
    pub user_code: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut monad_async_task_head) -> monad_async_result,
    >,
    pub user_ptr: *mut ::std::os::raw::c_void,
    pub is_pending_launch: bool,
    pub is_running: bool,
    pub is_suspended_awaiting: bool,
    pub is_suspended_completed: bool,
    pub pending_launch_queue_: monad_async_priority,
    pub current_executor: monad_async_executor,
    pub ticks_when_attached: monad_async_cpu_ticks_count_t,
    pub ticks_when_detached: monad_async_cpu_ticks_count_t,
    pub ticks_when_suspended_awaiting: monad_async_cpu_ticks_count_t,
    pub ticks_when_suspended_completed: monad_async_cpu_ticks_count_t,
    pub ticks_when_resumed: monad_async_cpu_ticks_count_t,
    pub total_ticks_executed: monad_async_cpu_ticks_count_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct monad_async_task_head__bindgen_ty_1 {
    pub cpu: monad_async_priority,
    pub io: monad_async_priority,
}
#[test]
fn bindgen_test_layout_monad_async_task_head__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<monad_async_task_head__bindgen_ty_1>(),
        2usize,
        concat!("Size of: ", stringify!(monad_async_task_head__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<monad_async_task_head__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(monad_async_task_head__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<monad_async_task_head__bindgen_ty_1>())).cpu as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(monad_async_task_head__bindgen_ty_1),
            "::",
            stringify!(cpu)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<monad_async_task_head__bindgen_ty_1>())).io as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(monad_async_task_head__bindgen_ty_1),
            "::",
            stringify!(io)
        )
    );
}
#[test]
fn bindgen_test_layout_monad_async_task_head() {
    assert_eq!(
        ::std::mem::size_of::<monad_async_task_head>(),
        120usize,
        concat!("Size of: ", stringify!(monad_async_task_head))
    );
    assert_eq!(
        ::std::mem::align_of::<monad_async_task_head>(),
        8usize,
        concat!("Alignment of ", stringify!(monad_async_task_head))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<monad_async_task_head>())).priority as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(monad_async_task_head),
            "::",
            stringify!(priority)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<monad_async_task_head>())).result as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(monad_async_task_head),
            "::",
            stringify!(result)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<monad_async_task_head>())).user_code as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(monad_async_task_head),
            "::",
            stringify!(user_code)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<monad_async_task_head>())).user_ptr as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(monad_async_task_head),
            "::",
            stringify!(user_ptr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<monad_async_task_head>())).is_pending_launch as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(monad_async_task_head),
            "::",
            stringify!(is_pending_launch)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<monad_async_task_head>())).is_running as *const _ as usize
        },
        57usize,
        concat!(
            "Offset of field: ",
            stringify!(monad_async_task_head),
            "::",
            stringify!(is_running)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<monad_async_task_head>())).is_suspended_awaiting as *const _
                as usize
        },
        58usize,
        concat!(
            "Offset of field: ",
            stringify!(monad_async_task_head),
            "::",
            stringify!(is_suspended_awaiting)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<monad_async_task_head>())).is_suspended_completed as *const _
                as usize
        },
        59usize,
        concat!(
            "Offset of field: ",
            stringify!(monad_async_task_head),
            "::",
            stringify!(is_suspended_completed)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<monad_async_task_head>())).pending_launch_queue_ as *const _
                as usize
        },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(monad_async_task_head),
            "::",
            stringify!(pending_launch_queue_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<monad_async_task_head>())).current_executor as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(monad_async_task_head),
            "::",
            stringify!(current_executor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<monad_async_task_head>())).ticks_when_attached as *const _
                as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(monad_async_task_head),
            "::",
            stringify!(ticks_when_attached)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<monad_async_task_head>())).ticks_when_detached as *const _
                as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(monad_async_task_head),
            "::",
            stringify!(ticks_when_detached)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<monad_async_task_head>())).ticks_when_suspended_awaiting
                as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(monad_async_task_head),
            "::",
            stringify!(ticks_when_suspended_awaiting)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<monad_async_task_head>())).ticks_when_suspended_completed
                as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(monad_async_task_head),
            "::",
            stringify!(ticks_when_suspended_completed)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<monad_async_task_head>())).ticks_when_resumed as *const _
                as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(monad_async_task_head),
            "::",
            stringify!(ticks_when_resumed)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<monad_async_task_head>())).total_ticks_executed as *const _
                as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(monad_async_task_head),
            "::",
            stringify!(total_ticks_executed)
        )
    );
}
pub type monad_async_task = *mut monad_async_task_head;
#[doc = "! \\brief Attributes by which to construct a task"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct monad_async_task_attr {
    pub stack_size: size_t,
}
#[test]
fn bindgen_test_layout_monad_async_task_attr() {
    assert_eq!(
        ::std::mem::size_of::<monad_async_task_attr>(),
        8usize,
        concat!("Size of: ", stringify!(monad_async_task_attr))
    );
    assert_eq!(
        ::std::mem::align_of::<monad_async_task_attr>(),
        8usize,
        concat!("Alignment of ", stringify!(monad_async_task_attr))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<monad_async_task_attr>())).stack_size as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(monad_async_task_attr),
            "::",
            stringify!(stack_size)
        )
    );
}
extern "C" {
    #[doc = "! \\brief EXPENSIVE Creates a task instance."]
    pub fn monad_async_task_create(
        task: *mut monad_async_task,
        attr: *mut monad_async_task_attr,
    ) -> monad_async_result;
}
extern "C" {
    #[doc = "! \\brief EXPENSIVE Destroys a task instance."]
    pub fn monad_async_task_destroy(task: monad_async_task) -> monad_async_result;
}
extern "C" {
    #[doc = "! \\brief THREADSAFE Attaches a task instance onto a given executor, which means it will launch the next time the executor runs."]
    #[doc = "! If the task is attached already to a different executor, you MUST call this function from that executor's kernel thread."]
    pub fn monad_async_task_attach(
        executor: monad_async_executor,
        task: monad_async_task,
    ) -> monad_async_result;
}
extern "C" {
    #[doc = "! \\brief Suspend execution of a task for a given duration, which can be zero (which equates \"yield\")."]
    pub fn monad_async_task_suspend_for_duration(
        task: monad_async_task,
        ns: u64,
    ) -> monad_async_result;
}
pub type __u32 = ::std::os::raw::c_uint;
pub type __u64 = ::std::os::raw::c_ulonglong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct io_sqring_offsets {
    pub head: __u32,
    pub tail: __u32,
    pub ring_mask: __u32,
    pub ring_entries: __u32,
    pub flags: __u32,
    pub dropped: __u32,
    pub array: __u32,
    pub resv1: __u32,
    pub resv2: __u64,
}
#[test]
fn bindgen_test_layout_io_sqring_offsets() {
    assert_eq!(
        ::std::mem::size_of::<io_sqring_offsets>(),
        40usize,
        concat!("Size of: ", stringify!(io_sqring_offsets))
    );
    assert_eq!(
        ::std::mem::align_of::<io_sqring_offsets>(),
        8usize,
        concat!("Alignment of ", stringify!(io_sqring_offsets))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<io_sqring_offsets>())).head as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(io_sqring_offsets),
            "::",
            stringify!(head)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<io_sqring_offsets>())).tail as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(io_sqring_offsets),
            "::",
            stringify!(tail)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<io_sqring_offsets>())).ring_mask as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(io_sqring_offsets),
            "::",
            stringify!(ring_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<io_sqring_offsets>())).ring_entries as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(io_sqring_offsets),
            "::",
            stringify!(ring_entries)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<io_sqring_offsets>())).flags as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(io_sqring_offsets),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<io_sqring_offsets>())).dropped as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(io_sqring_offsets),
            "::",
            stringify!(dropped)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<io_sqring_offsets>())).array as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(io_sqring_offsets),
            "::",
            stringify!(array)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<io_sqring_offsets>())).resv1 as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(io_sqring_offsets),
            "::",
            stringify!(resv1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<io_sqring_offsets>())).resv2 as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(io_sqring_offsets),
            "::",
            stringify!(resv2)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct io_cqring_offsets {
    pub head: __u32,
    pub tail: __u32,
    pub ring_mask: __u32,
    pub ring_entries: __u32,
    pub overflow: __u32,
    pub cqes: __u32,
    pub flags: __u32,
    pub resv1: __u32,
    pub resv2: __u64,
}
#[test]
fn bindgen_test_layout_io_cqring_offsets() {
    assert_eq!(
        ::std::mem::size_of::<io_cqring_offsets>(),
        40usize,
        concat!("Size of: ", stringify!(io_cqring_offsets))
    );
    assert_eq!(
        ::std::mem::align_of::<io_cqring_offsets>(),
        8usize,
        concat!("Alignment of ", stringify!(io_cqring_offsets))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<io_cqring_offsets>())).head as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(io_cqring_offsets),
            "::",
            stringify!(head)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<io_cqring_offsets>())).tail as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(io_cqring_offsets),
            "::",
            stringify!(tail)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<io_cqring_offsets>())).ring_mask as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(io_cqring_offsets),
            "::",
            stringify!(ring_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<io_cqring_offsets>())).ring_entries as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(io_cqring_offsets),
            "::",
            stringify!(ring_entries)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<io_cqring_offsets>())).overflow as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(io_cqring_offsets),
            "::",
            stringify!(overflow)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<io_cqring_offsets>())).cqes as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(io_cqring_offsets),
            "::",
            stringify!(cqes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<io_cqring_offsets>())).flags as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(io_cqring_offsets),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<io_cqring_offsets>())).resv1 as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(io_cqring_offsets),
            "::",
            stringify!(resv1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<io_cqring_offsets>())).resv2 as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(io_cqring_offsets),
            "::",
            stringify!(resv2)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct io_uring_params {
    pub sq_entries: __u32,
    pub cq_entries: __u32,
    pub flags: __u32,
    pub sq_thread_cpu: __u32,
    pub sq_thread_idle: __u32,
    pub features: __u32,
    pub wq_fd: __u32,
    pub resv: [__u32; 3usize],
    pub sq_off: io_sqring_offsets,
    pub cq_off: io_cqring_offsets,
}
#[test]
fn bindgen_test_layout_io_uring_params() {
    assert_eq!(
        ::std::mem::size_of::<io_uring_params>(),
        120usize,
        concat!("Size of: ", stringify!(io_uring_params))
    );
    assert_eq!(
        ::std::mem::align_of::<io_uring_params>(),
        8usize,
        concat!("Alignment of ", stringify!(io_uring_params))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<io_uring_params>())).sq_entries as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(io_uring_params),
            "::",
            stringify!(sq_entries)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<io_uring_params>())).cq_entries as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(io_uring_params),
            "::",
            stringify!(cq_entries)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<io_uring_params>())).flags as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(io_uring_params),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<io_uring_params>())).sq_thread_cpu as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(io_uring_params),
            "::",
            stringify!(sq_thread_cpu)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<io_uring_params>())).sq_thread_idle as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(io_uring_params),
            "::",
            stringify!(sq_thread_idle)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<io_uring_params>())).features as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(io_uring_params),
            "::",
            stringify!(features)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<io_uring_params>())).wq_fd as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(io_uring_params),
            "::",
            stringify!(wq_fd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<io_uring_params>())).resv as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(io_uring_params),
            "::",
            stringify!(resv)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<io_uring_params>())).sq_off as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(io_uring_params),
            "::",
            stringify!(sq_off)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<io_uring_params>())).cq_off as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(io_uring_params),
            "::",
            stringify!(cq_off)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct monad_async_executor_head {
    pub current_task: monad_async_task,
    pub tasks_pending_launch: size_t,
    pub tasks_running: size_t,
    pub tasks_suspended: size_t,
}
#[test]
fn bindgen_test_layout_monad_async_executor_head() {
    assert_eq!(
        ::std::mem::size_of::<monad_async_executor_head>(),
        32usize,
        concat!("Size of: ", stringify!(monad_async_executor_head))
    );
    assert_eq!(
        ::std::mem::align_of::<monad_async_executor_head>(),
        8usize,
        concat!("Alignment of ", stringify!(monad_async_executor_head))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<monad_async_executor_head>())).current_task as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(monad_async_executor_head),
            "::",
            stringify!(current_task)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<monad_async_executor_head>())).tasks_pending_launch as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(monad_async_executor_head),
            "::",
            stringify!(tasks_pending_launch)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<monad_async_executor_head>())).tasks_running as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(monad_async_executor_head),
            "::",
            stringify!(tasks_running)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<monad_async_executor_head>())).tasks_suspended as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(monad_async_executor_head),
            "::",
            stringify!(tasks_suspended)
        )
    );
}
#[doc = "! \\brief Attributes by which to construct an executor"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct monad_async_executor_attr {
    pub io_uring_ring: monad_async_executor_attr__bindgen_ty_1,
    pub io_uring_wr_ring: monad_async_executor_attr__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct monad_async_executor_attr__bindgen_ty_1 {
    pub entries: ::std::os::raw::c_uint,
    pub params: io_uring_params,
}
#[test]
fn bindgen_test_layout_monad_async_executor_attr__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<monad_async_executor_attr__bindgen_ty_1>(),
        128usize,
        concat!(
            "Size of: ",
            stringify!(monad_async_executor_attr__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<monad_async_executor_attr__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(monad_async_executor_attr__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<monad_async_executor_attr__bindgen_ty_1>())).entries as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(monad_async_executor_attr__bindgen_ty_1),
            "::",
            stringify!(entries)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<monad_async_executor_attr__bindgen_ty_1>())).params as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(monad_async_executor_attr__bindgen_ty_1),
            "::",
            stringify!(params)
        )
    );
}
#[test]
fn bindgen_test_layout_monad_async_executor_attr() {
    assert_eq!(
        ::std::mem::size_of::<monad_async_executor_attr>(),
        256usize,
        concat!("Size of: ", stringify!(monad_async_executor_attr))
    );
    assert_eq!(
        ::std::mem::align_of::<monad_async_executor_attr>(),
        8usize,
        concat!("Alignment of ", stringify!(monad_async_executor_attr))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<monad_async_executor_attr>())).io_uring_ring as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(monad_async_executor_attr),
            "::",
            stringify!(io_uring_ring)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<monad_async_executor_attr>())).io_uring_wr_ring as *const _
                as usize
        },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(monad_async_executor_attr),
            "::",
            stringify!(io_uring_wr_ring)
        )
    );
}
extern "C" {
    #[doc = "! \\brief EXPENSIVE Creates an executor instance. You must create it on the kernel thread where it will be used."]
    pub fn monad_async_executor_create(
        ex: *mut monad_async_executor,
        attr: *mut monad_async_executor_attr,
    ) -> monad_async_result;
}
extern "C" {
    #[doc = "! \\brief EXPENSIVE Destroys an executor instance."]
    pub fn monad_async_executor_destroy(ex: monad_async_executor) -> monad_async_result;
}
extern "C" {
    #[doc = "! \\brief Processes no more than `max_items` work items, returning the number of items processed which will be at least one."]
    #[doc = "! A null `timeout` means wait forever, and a zero timeout will poll without blocking."]
    pub fn monad_async_executor_run(
        ex: monad_async_executor,
        max_items: size_t,
        timeout: *mut timespec,
    ) -> monad_async_result;
}
