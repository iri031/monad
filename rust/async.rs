/* automatically generated by rust-bindgen 0.59.1 */

pub type __uint32_t = ::std::os::raw::c_uint;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __time_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cxx_status_code_system {
    pub domain: *mut ::std::os::raw::c_void,
    pub value: isize,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cxx_result_status_code_system_monad_async {
    pub value: isize,
    pub flags: ::std::os::raw::c_uint,
    pub error: cxx_status_code_system,
}
#[doc = "! \\brief Convenience typedef"]
pub type monad_async_result = cxx_result_status_code_system_monad_async;
extern "C" {
    #[doc = "! \\brief Return a successful `monad_async_result` for a given `intptr_t`"]
    pub fn monad_async_make_success(v: isize) -> monad_async_result;
}
extern "C" {
    #[doc = "! \\brief Return a failure `monad_async_result` for a given `errno`"]
    pub fn monad_async_make_failure(ec: ::std::os::raw::c_int) -> monad_async_result;
}
#[doc = "! \\brief A type representing the tick count on the CPU"]
pub type monad_async_cpu_ticks_count_t = u64;
pub const monad_async_priority_monad_async_priority_high: monad_async_priority = 0;
pub const monad_async_priority_monad_async_priority_normal: monad_async_priority = 1;
pub const monad_async_priority_monad_async_priority_low: monad_async_priority = 2;
pub const monad_async_priority_monad_async_priority_max: monad_async_priority = 3;
#[doc = "! \\brief Task priority classes"]
pub type monad_async_priority = ::std::os::raw::c_uchar;
pub type size_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
pub type __u32 = ::std::os::raw::c_uint;
pub type __u64 = ::std::os::raw::c_ulonglong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct io_sqring_offsets {
    pub head: __u32,
    pub tail: __u32,
    pub ring_mask: __u32,
    pub ring_entries: __u32,
    pub flags: __u32,
    pub dropped: __u32,
    pub array: __u32,
    pub resv1: __u32,
    pub resv2: __u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct io_cqring_offsets {
    pub head: __u32,
    pub tail: __u32,
    pub ring_mask: __u32,
    pub ring_entries: __u32,
    pub overflow: __u32,
    pub cqes: __u32,
    pub flags: __u32,
    pub resv1: __u32,
    pub resv2: __u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct io_uring_params {
    pub sq_entries: __u32,
    pub cq_entries: __u32,
    pub flags: __u32,
    pub sq_thread_cpu: __u32,
    pub sq_thread_idle: __u32,
    pub features: __u32,
    pub wq_fd: __u32,
    pub resv: [__u32; 3usize],
    pub sq_off: io_sqring_offsets,
    pub cq_off: io_cqring_offsets,
}
pub type atomic_bool = u8;
pub type atomic_uint = u32;
pub type atomic_size_t = u64;
pub type monad_async_task = *mut monad_async_task_head;
pub type monad_async_context = *mut monad_async_context_head;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct monad_async_context_switcher_head {
    pub user_ptr: *mut ::std::os::raw::c_void,
    #[doc = "! The number of contexts existing"]
    pub contexts: size_t,
    #[doc = "! \\brief Destroys self"]
    pub self_destroy: ::std::option::Option<
        unsafe extern "C" fn(
            switcher: *mut monad_async_context_switcher_head,
        ) -> monad_async_result,
    >,
    #[doc = "! \\brief Create a switchable context for a task"]
    pub create: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut monad_async_context,
            switcher: *mut monad_async_context_switcher_head,
            task: monad_async_task,
            attr: *const monad_async_task_attr,
        ) -> monad_async_result,
    >,
    #[doc = "! \\brief Destroys a switchable context"]
    pub destroy: ::std::option::Option<
        unsafe extern "C" fn(context: monad_async_context) -> monad_async_result,
    >,
    #[doc = "! \\brief If running within a switchable context, suspend it and call"]
    #[doc = "! resume on the new context via its context switcher"]
    pub suspend_and_call_resume: ::std::option::Option<
        unsafe extern "C" fn(
            current_context: monad_async_context,
            new_context: monad_async_context,
        ),
    >,
    #[doc = "! \\brief Resume execution of a previously suspended switchable context."]
    #[doc = "! Some context switchers will return from this function when the resumed"]
    #[doc = "! task next suspends, others will resume at the suspension point set by"]
    #[doc = "! `executor_resume_many`."]
    pub resume: ::std::option::Option<
        unsafe extern "C" fn(
            current_context: monad_async_context,
            new_context: monad_async_context,
        ),
    >,
    #[doc = "! \\brief To avoid having to set a resumption point per task when resuming"]
    #[doc = "! many tasks from the central loop of the executor, set a single"]
    #[doc = "! resumption point and call the supplied function every time a task"]
    #[doc = "! resumed within the supplied function suspends. This can be very"]
    #[doc = "! considerably more efficient for some types of context switcher."]
    pub resume_many: ::std::option::Option<
        unsafe extern "C" fn(
            switcher: *mut monad_async_context_switcher_head,
            resumed: ::std::option::Option<
                unsafe extern "C" fn(
                    user_ptr: *mut ::std::os::raw::c_void,
                    fake_current_context: monad_async_context,
                ) -> monad_async_result,
            >,
            user_ptr: *mut ::std::os::raw::c_void,
        ) -> monad_async_result,
    >,
}
pub type monad_async_context_switcher = *mut monad_async_context_switcher_head;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct monad_async_context_switcher_impl {
    #[doc = "! \\brief Create a switcher of contexts. The"]
    #[doc = "! executor creates one of these per executor."]
    pub create: ::std::option::Option<
        unsafe extern "C" fn(switcher: *mut monad_async_context_switcher) -> monad_async_result,
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct monad_async_context_head {
    pub is_running: bool,
    pub is_suspended: bool,
    pub switcher: monad_async_context_switcher,
    pub sanitizer: monad_async_context_head__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct monad_async_context_head__bindgen_ty_1 {
    pub fake_stack_save: *mut ::std::os::raw::c_void,
    pub bottom: *const ::std::os::raw::c_void,
    pub size: size_t,
}
extern "C" {
    #[doc = "! \\brief Destroys any context switcher"]
    pub fn monad_async_context_switcher_destroy(
        switcher: monad_async_context_switcher,
    ) -> monad_async_result;
}
extern "C" {
    #[doc = "! \\brief Creates a `setjmp`/`longjmp` based context switcher with each task"]
    #[doc = "! getting its own stack"]
    pub fn monad_async_context_switcher_sjlj_create(
        switcher: *mut monad_async_context_switcher,
    ) -> monad_async_result;
}
extern "C" {
    #[doc = " \\brief Creates a none context switcher which can't suspend-resume. Useful"]
    #[doc = "for threadpool implementation."]
    #[doc = ""]
    #[doc = "As this context switcher never suspends and resumes, it is safe to use a single"]
    #[doc = "instance of this across multiple threads. In fact, the current implementation"]
    #[doc = "always returns a static instance, and destruction does nothing."]
    pub fn monad_async_context_switcher_none_create(
        switcher: *mut monad_async_context_switcher,
    ) -> monad_async_result;
}
#[doc = "! \\brief The public attributes of an executor"]
pub type monad_async_executor = *mut monad_async_executor_head;
#[doc = "! \\brief An i/o status state used to identify an i/o in progress. Must NOT"]
#[doc = "! move in memory until the operation completes."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct monad_async_io_status {
    pub prev: *mut monad_async_io_status,
    pub next: *mut monad_async_io_status,
    pub cancel_: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: monad_async_task,
            arg2: *mut monad_async_io_status,
        ) -> monad_async_result,
    >,
    #[doc = "! Unspecified value immediately after initiating call returns. Will become"]
    #[doc = "! bytes transferred if operation is successful, or another error if it"]
    #[doc = "! fails or is cancelled."]
    pub result: monad_async_result,
    pub ticks_when_initiated: monad_async_cpu_ticks_count_t,
    pub ticks_when_completed: monad_async_cpu_ticks_count_t,
    pub ticks_when_reaped: monad_async_cpu_ticks_count_t,
}
#[doc = "! \\brief The public attributes of a task"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct monad_async_task_head {
    pub priority: monad_async_task_head__bindgen_ty_1,
    pub result: monad_async_result,
    pub user_code: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut monad_async_task_head) -> monad_async_result,
    >,
    pub user_ptr: *mut ::std::os::raw::c_void,
    pub current_executor: u64,
    pub is_awaiting_dispatch: atomic_bool,
    pub is_pending_launch: atomic_bool,
    pub is_running: atomic_bool,
    pub is_suspended_awaiting: atomic_bool,
    pub is_suspended_completed: atomic_bool,
    pub pending_launch_queue_: monad_async_priority,
    pub ticks_when_submitted: monad_async_cpu_ticks_count_t,
    pub ticks_when_attached: monad_async_cpu_ticks_count_t,
    pub ticks_when_detached: monad_async_cpu_ticks_count_t,
    pub ticks_when_suspended_awaiting: monad_async_cpu_ticks_count_t,
    pub ticks_when_suspended_completed: monad_async_cpu_ticks_count_t,
    pub ticks_when_resumed: monad_async_cpu_ticks_count_t,
    pub total_ticks_executed: monad_async_cpu_ticks_count_t,
    pub io_submitted: size_t,
    pub io_completed_not_reaped: size_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct monad_async_task_head__bindgen_ty_1 {
    pub cpu: monad_async_priority,
    pub io: monad_async_priority,
}
#[doc = "! \\brief Attributes by which to construct a task"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct monad_async_task_attr {
    #[doc = "! \\brief 0 chooses platform default stack size"]
    pub stack_size: size_t,
}
extern "C" {
    #[doc = "! \\brief EXPENSIVE Creates a task instance using the specified context"]
    #[doc = "! switcher."]
    pub fn monad_async_task_create(
        task: *mut monad_async_task,
        switcher: monad_async_context_switcher,
        attr: *mut monad_async_task_attr,
    ) -> monad_async_result;
}
extern "C" {
    #[doc = "! \\brief EXPENSIVE Destroys a task instance. If the task is currently"]
    #[doc = "! suspended, it will be cancelled first in which case `EAGAIN` may be returned"]
    #[doc = "! from this function until cancellation succeeds."]
    pub fn monad_async_task_destroy(task: monad_async_task) -> monad_async_result;
}
extern "C" {
    #[doc = "! \\brief THREADSAFE Attaches a task instance onto a given executor, which"]
    #[doc = "! means it will launch the next time the executor runs. If the task is"]
    #[doc = "! attached already to a different executor, you MUST call this function from"]
    #[doc = "! that executor's kernel thread. If you optionally choose to reparent the"]
    #[doc = "! task's context to a new context switcher instance (typical if attaching"]
    #[doc = "! to an executor on a different kernel thread), it MUST be the same type of"]
    #[doc = "! context switcher."]
    pub fn monad_async_task_attach(
        executor: monad_async_executor,
        task: monad_async_task,
        opt_reparent_switcher: monad_async_context_switcher,
    ) -> monad_async_result;
}
extern "C" {
    #[doc = "! \\brief THREADSAFE If a task is currently suspended on an operation, cancel"]
    #[doc = "! it. This can take some time for the relevant io_uring operation to also"]
    #[doc = "! cancel. If the task is yet to launch, don't launch it. If the task isn't"]
    #[doc = "! currently running, returns `ENOENT`. The suspension point will return"]
    #[doc = "! `ECANCELED` next time the task resumes."]
    pub fn monad_async_task_cancel(
        executor: monad_async_executor,
        task: monad_async_task,
    ) -> monad_async_result;
}
extern "C" {
    #[doc = "! \\brief Ask io_uring to cancel a previously initiated operation. It can take"]
    #[doc = "! some time for io_uring to cancel an operation, and it may ignore your"]
    #[doc = "! request."]
    pub fn monad_async_task_io_cancel(
        task: monad_async_task,
        iostatus: *mut monad_async_io_status,
    ) -> monad_async_result;
}
extern "C" {
    #[doc = "! \\brief Iterate through completed i/o for this task, reaping each from the"]
    #[doc = "! completed but not repeated list."]
    pub fn monad_async_task_completed_io(task: monad_async_task) -> *mut monad_async_io_status;
}
extern "C" {
    #[doc = "! \\brief Suspend execution of a task for a given duration, which can be zero"]
    #[doc = "! (which equates \"yield\"). If `completed` is not null, if any i/o which the"]
    #[doc = "! task has initiated completes during the suspension, resume the task setting"]
    #[doc = "! `completed` to which i/o has just completed."]
    pub fn monad_async_task_suspend_for_duration(
        completed: *mut *mut monad_async_io_status,
        task: monad_async_task,
        ns: u64,
    ) -> monad_async_result;
}
#[doc = "! \\brief The public attributes of an executor"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct monad_async_executor_head {
    pub current_task: u64,
    pub tasks_pending_launch: atomic_size_t,
    pub tasks_running: atomic_size_t,
    pub tasks_suspended: atomic_size_t,
    pub total_ticks_in_run: monad_async_cpu_ticks_count_t,
    pub total_ticks_in_task_launch: monad_async_cpu_ticks_count_t,
    pub total_ticks_in_io_uring: monad_async_cpu_ticks_count_t,
    pub total_ticks_sleeping: monad_async_cpu_ticks_count_t,
    pub total_ticks_in_task_completion: monad_async_cpu_ticks_count_t,
}
#[doc = "! \\brief Attributes by which to construct an executor"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct monad_async_executor_attr {
    pub io_uring_ring: monad_async_executor_attr__bindgen_ty_1,
    pub io_uring_wr_ring: monad_async_executor_attr__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct monad_async_executor_attr__bindgen_ty_1 {
    #[doc = "! \\brief If this is zero, this executor will be incapable of doing"]
    #[doc = "! i/o! It also no longer initialises io_uring for this executor."]
    pub entries: ::std::os::raw::c_uint,
    pub params: io_uring_params,
}
extern "C" {
    #[doc = " \\brief EXPENSIVE Creates an executor instance. You must create it on the"]
    #[doc = "kernel thread where it will be used."]
    #[doc = ""]
    #[doc = "Generally, one also needs to create context switcher instances for each"]
    #[doc = "executor instance. This is because the context switcher needs to store how"]
    #[doc = "to resume the executor when a task's execution suspends."]
    pub fn monad_async_executor_create(
        ex: *mut monad_async_executor,
        attr: *mut monad_async_executor_attr,
    ) -> monad_async_result;
}
extern "C" {
    #[doc = "! \\brief EXPENSIVE Destroys an executor instance."]
    pub fn monad_async_executor_destroy(ex: monad_async_executor) -> monad_async_result;
}
extern "C" {
    #[doc = "! \\brief Processes no more than `max_items` work items, returning the number"]
    #[doc = "! of items processed which will be at least one. A null `timeout` means wait"]
    #[doc = "! forever, and a zero timeout will poll without blocking."]
    pub fn monad_async_executor_run(
        ex: monad_async_executor,
        max_items: size_t,
        timeout: *mut timespec,
    ) -> monad_async_result;
}
extern "C" {
    #[doc = "! \\brief THREADSAFE Causes a sleeping executor to wake. Can be called from any"]
    #[doc = "! kernel thread. `cause_run_to_return` causes `monad_async_executor_run()` to"]
    #[doc = "! return the result given, otherwise the internal sleep wakes, executor state"]
    #[doc = "! is examined for new work and the sleep reestablished."]
    pub fn monad_async_executor_wake(
        ex: monad_async_executor,
        cause_run_to_return: *const monad_async_result,
    ) -> monad_async_result;
}
#[doc = "! \\brief The public attributes of a work dispatcher"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct monad_async_work_dispatcher_head {
    pub executors: monad_async_work_dispatcher_head__bindgen_ty_1,
    pub tasks_awaiting_dispatch: atomic_size_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct monad_async_work_dispatcher_head__bindgen_ty_1 {
    pub working: atomic_uint,
    pub idle: atomic_uint,
}
#[doc = "! \\brief The public attributes of a work dispatcher"]
pub type monad_async_work_dispatcher = *mut monad_async_work_dispatcher_head;
#[doc = "! \\brief The public attributes of a work dispatcher"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct monad_async_work_dispatcher_executor_head {
    pub derived: *mut monad_async_executor_head,
    pub dispatcher: monad_async_work_dispatcher,
    pub is_working: atomic_bool,
    pub is_idle: atomic_bool,
}
#[doc = "! \\brief The public attributes of a work dispatcher"]
pub type monad_async_work_dispatcher_executor = *mut monad_async_work_dispatcher_executor_head;
#[doc = "! \\brief Attributes by which to construct a work dispatcher"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct monad_async_work_dispatcher_attr {
    #[doc = "! Dispatcher executors should spin the CPU for this many milliseconds"]
    #[doc = "! before sleeping"]
    pub spin_before_sleep_ms: u32,
}
#[doc = "! \\brief Attributes by which to construct a work dispatcher"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct monad_async_work_dispatcher_executor_attr {
    pub derived: monad_async_executor_attr,
}
extern "C" {
    #[doc = "! \\brief EXPENSIVE Creates a work dispatcher instance."]
    pub fn monad_async_work_dispatcher_create(
        dp: *mut monad_async_work_dispatcher,
        attr: *mut monad_async_work_dispatcher_attr,
    ) -> monad_async_result;
}
extern "C" {
    #[doc = "! \\brief EXPENSIVE Destroys a work dispatcher instance."]
    pub fn monad_async_work_dispatcher_destroy(
        dp: monad_async_work_dispatcher,
    ) -> monad_async_result;
}
extern "C" {
    #[doc = "! \\brief EXPENSIVE Creates a work dispatcher executor instance."]
    pub fn monad_async_work_dispatcher_executor_create(
        ex: *mut monad_async_work_dispatcher_executor,
        dp: monad_async_work_dispatcher,
        attr: *mut monad_async_work_dispatcher_executor_attr,
    ) -> monad_async_result;
}
extern "C" {
    #[doc = "! \\brief EXPENSIVE Destroys a work dispatcher executor instance."]
    pub fn monad_async_work_dispatcher_executor_destroy(
        ex: monad_async_work_dispatcher_executor,
    ) -> monad_async_result;
}
extern "C" {
    #[doc = "! \\brief Calls `monad_async_executor_run()` for the calling kernel thread,"]
    #[doc = "! attaching tasks recently submitted to kernel threads in the pool with spare"]
    #[doc = "! capacity as per the work dispatcher's configured policy. Returns the number"]
    #[doc = "! of work items executed, or -1 when time to exit."]
    pub fn monad_async_work_dispatcher_executor_run(
        ex: monad_async_work_dispatcher_executor,
    ) -> monad_async_result;
}
extern "C" {
    #[doc = "! \\brief THREADSAFE Causes a sleeping work dispatcher executor to wake. Same"]
    #[doc = "! as `monad_async_executor_wake()`, but for work dispatcher executors."]
    pub fn monad_async_work_dispatcher_executor_wake(
        ex: monad_async_work_dispatcher_executor,
        cause_run_to_return: *const monad_async_result,
    ) -> monad_async_result;
}
extern "C" {
    #[doc = "! \\brief THREADSAFE Submits one or more tasks to be executed by the first"]
    #[doc = "! available executor within the work dispatcher pool. Higher priority tasks"]
    #[doc = "! are executed before lower priority tasks."]
    pub fn monad_async_work_dispatcher_submit(
        dp: monad_async_work_dispatcher,
        tasks: *mut monad_async_task,
        count: size_t,
    ) -> monad_async_result;
}
extern "C" {
    #[doc = "! \\brief THREADSAFE Wait until all work has been dispatched or executed."]
    pub fn monad_async_work_dispatcher_wait(
        dp: monad_async_work_dispatcher,
        max_undispatched: size_t,
        max_unexecuted: size_t,
        timeout: *mut timespec,
    ) -> monad_async_result;
}
extern "C" {
    #[doc = "! \\brief THREADSAFE Tells executors to quit, preferring idle executors first,"]
    #[doc = "! until no more than `max_executors` remains."]
    pub fn monad_async_work_dispatcher_quit(
        dp: monad_async_work_dispatcher,
        max_executors: size_t,
        timeout: *mut timespec,
    ) -> monad_async_result;
}
