/* automatically generated by rust-bindgen 0.59.1 */

pub type __uint32_t = ::std::os::raw::c_uint;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __time_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cxx_status_code_system {
    pub domain: *mut ::std::os::raw::c_void,
    pub value: isize,
}
impl Default for cxx_status_code_system {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cxx_result_status_code_system_monad_async {
    pub value: isize,
    pub flags: ::std::os::raw::c_uint,
    pub error: cxx_status_code_system,
}
impl Default for cxx_result_status_code_system_monad_async {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "! \\brief Convenience typedef"]
pub type monad_async_result = cxx_result_status_code_system_monad_async;
extern "C" {
    #[doc = "! \\brief Return a successful `monad_async_result` for a given `intptr_t`"]
    pub fn monad_async_make_success(v: isize) -> monad_async_result;
}
extern "C" {
    #[doc = "! \\brief Return a failure `monad_async_result` for a given `errno`"]
    pub fn monad_async_make_failure(ec: ::std::os::raw::c_int) -> monad_async_result;
}
#[doc = "! \\brief A type representing the tick count on the CPU"]
pub type monad_async_cpu_ticks_count_t = u64;
pub const monad_async_priority_monad_async_priority_high: monad_async_priority = 0;
pub const monad_async_priority_monad_async_priority_normal: monad_async_priority = 1;
pub const monad_async_priority_monad_async_priority_low: monad_async_priority = 2;
pub const monad_async_priority_monad_async_priority_max: monad_async_priority = 3;
pub const monad_async_priority_monad_async_priority_unchanged: monad_async_priority = 255;
#[doc = "! \\brief Task priority classes"]
pub type monad_async_priority = ::std::os::raw::c_uchar;
pub type size_t = ::std::os::raw::c_ulong;
pub type atomic_bool = u8;
pub type atomic_uint = u32;
pub type atomic_size_t = u64;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
pub type monad_async_task = *mut monad_async_task_head;
pub type monad_async_context = *mut monad_async_context_head;
#[repr(C)]
#[derive(Debug)]
pub struct monad_async_context_switcher_head {
    pub user_ptr: *mut ::std::os::raw::c_void,
    pub contexts: atomic_uint,
    #[doc = "! \\brief Destroys self"]
    pub self_destroy: ::std::option::Option<
        unsafe extern "C" fn(
            switcher: *mut monad_async_context_switcher_head,
        ) -> monad_async_result,
    >,
    #[doc = "! \\brief Create a switchable context for a task"]
    pub create: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut monad_async_context,
            switcher: *mut monad_async_context_switcher_head,
            task: monad_async_task,
            attr: *const monad_async_task_attr,
        ) -> monad_async_result,
    >,
    #[doc = "! \\brief Destroys a switchable context"]
    pub destroy: ::std::option::Option<
        unsafe extern "C" fn(context: monad_async_context) -> monad_async_result,
    >,
    #[doc = "! \\brief If running within a switchable context, suspend it and call"]
    #[doc = "! resume on the new context via its context switcher"]
    pub suspend_and_call_resume: ::std::option::Option<
        unsafe extern "C" fn(
            current_context: monad_async_context,
            new_context: monad_async_context,
        ),
    >,
    #[doc = "! \\brief Resume execution of a previously suspended switchable context."]
    #[doc = "! Some context switchers will return from this function when the resumed"]
    #[doc = "! task next suspends, others will resume at the suspension point set by"]
    #[doc = "! `resume_many`."]
    pub resume: ::std::option::Option<
        unsafe extern "C" fn(
            current_context: monad_async_context,
            new_context: monad_async_context,
        ),
    >,
    #[doc = "! \\brief To avoid having to set a resumption point per task when resuming"]
    #[doc = "! many tasks from the central loop of the executor, set a single"]
    #[doc = "! resumption point and call the supplied function every time a task"]
    #[doc = "! resumed within the supplied function suspends. This can be very"]
    #[doc = "! considerably more efficient for some types of context switcher."]
    pub resume_many: ::std::option::Option<
        unsafe extern "C" fn(
            switcher: *mut monad_async_context_switcher_head,
            resumed: ::std::option::Option<
                unsafe extern "C" fn(
                    user_ptr: *mut ::std::os::raw::c_void,
                    current_context_to_use_when_resuming: monad_async_context,
                ) -> monad_async_result,
            >,
            user_ptr: *mut ::std::os::raw::c_void,
        ) -> monad_async_result,
    >,
}
impl Default for monad_async_context_switcher_head {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type monad_async_context_switcher = *mut monad_async_context_switcher_head;
#[repr(C)]
#[derive(Debug, Default)]
pub struct monad_async_context_switcher_impl {
    #[doc = "! \\brief Create a switcher of contexts. The"]
    #[doc = "! executor creates one of these per executor."]
    pub create: ::std::option::Option<
        unsafe extern "C" fn(switcher: *mut monad_async_context_switcher) -> monad_async_result,
    >,
}
#[repr(C)]
#[derive(Debug)]
pub struct monad_async_context_head {
    pub is_running: bool,
    pub is_suspended: bool,
    pub switcher: u64,
    pub sanitizer: monad_async_context_head__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug)]
pub struct monad_async_context_head__bindgen_ty_1 {
    pub fake_stack_save: *mut ::std::os::raw::c_void,
    pub bottom: *const ::std::os::raw::c_void,
    pub size: size_t,
}
impl Default for monad_async_context_head__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for monad_async_context_head {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = "! \\brief Destroys any context switcher"]
    pub fn monad_async_context_switcher_destroy(
        switcher: monad_async_context_switcher,
    ) -> monad_async_result;
}
extern "C" {
    #[doc = "! \\brief Creates a `setjmp`/`longjmp` based context switcher with each task"]
    #[doc = "! getting its own stack"]
    pub fn monad_async_context_switcher_sjlj_create(
        switcher: *mut monad_async_context_switcher,
    ) -> monad_async_result;
}
extern "C" {
    #[doc = "! \\brief Convenience struct for setting a `setjmp`/`longjmp` based context"]
    #[doc = "! switcher"]
    pub static monad_async_context_switcher_sjlj: monad_async_context_switcher_impl;
}
extern "C" {
    #[doc = " \\brief Creates a none context switcher which can't suspend-resume. Useful"]
    #[doc = "for threadpool implementation."]
    #[doc = ""]
    #[doc = "As this context switcher never suspends and resumes, it is safe to use a single"]
    #[doc = "instance of this across multiple threads. In fact, the current implementation"]
    #[doc = "always returns a static instance, and destruction does nothing. You may"]
    #[doc = "therefore find `monad_async_context_switcher_none_instance()` more useful."]
    pub fn monad_async_context_switcher_none_create(
        switcher: *mut monad_async_context_switcher,
    ) -> monad_async_result;
}
extern "C" {
    #[doc = "! \\brief Convenience struct for setting a none context"]
    #[doc = "! switcher"]
    pub static monad_async_context_switcher_none: monad_async_context_switcher_impl;
}
extern "C" {
    #[doc = "! \\brief Convenience obtainer of the static none context switcher."]
    pub fn monad_async_context_switcher_none_instance() -> monad_async_context_switcher;
}
extern "C" {
    #[doc = "! \\brief Creates a Monad Fiber context switcher"]
    pub fn monad_async_context_switcher_fiber_create(
        switcher: *mut monad_async_context_switcher,
    ) -> monad_async_result;
}
extern "C" {
    #[doc = "! \\brief Convenience struct for setting a Monad Fiber context switcher"]
    pub static monad_async_context_switcher_fiber: monad_async_context_switcher_impl;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iovec {
    pub iov_base: *mut ::std::os::raw::c_void,
    pub iov_len: size_t,
}
impl Default for iovec {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type socklen_t = __socklen_t;
pub type sa_family_t = ::std::os::raw::c_ushort;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct sockaddr {
    pub sa_family: sa_family_t,
    pub sa_data: [::std::os::raw::c_char; 14usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct msghdr {
    pub msg_name: *mut ::std::os::raw::c_void,
    pub msg_namelen: socklen_t,
    pub msg_iov: *mut iovec,
    pub msg_iovlen: size_t,
    pub msg_control: *mut ::std::os::raw::c_void,
    pub msg_controllen: size_t,
    pub msg_flags: ::std::os::raw::c_int,
}
impl Default for msghdr {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type __u32 = ::std::os::raw::c_uint;
pub type __u64 = ::std::os::raw::c_ulonglong;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct open_how {
    pub flags: u64,
    pub mode: u64,
    pub resolve: u64,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct io_sqring_offsets {
    pub head: __u32,
    pub tail: __u32,
    pub ring_mask: __u32,
    pub ring_entries: __u32,
    pub flags: __u32,
    pub dropped: __u32,
    pub array: __u32,
    pub resv1: __u32,
    pub resv2: __u64,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct io_cqring_offsets {
    pub head: __u32,
    pub tail: __u32,
    pub ring_mask: __u32,
    pub ring_entries: __u32,
    pub overflow: __u32,
    pub cqes: __u32,
    pub flags: __u32,
    pub resv1: __u32,
    pub resv2: __u64,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct io_uring_params {
    pub sq_entries: __u32,
    pub cq_entries: __u32,
    pub flags: __u32,
    pub sq_thread_cpu: __u32,
    pub sq_thread_idle: __u32,
    pub features: __u32,
    pub wq_fd: __u32,
    pub resv: [__u32; 3usize],
    pub sq_off: io_sqring_offsets,
    pub cq_off: io_cqring_offsets,
}
#[doc = "! \\brief The public attributes of an executor"]
pub type monad_async_executor = *mut monad_async_executor_head;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct monad_fiber_task {
    _unused: [u8; 0],
}
#[doc = "! \\brief An i/o status state used to identify an i/o in progress. Must NOT"]
#[doc = "! move in memory until the operation completes."]
#[repr(C)]
#[derive(Debug)]
pub struct monad_async_io_status {
    pub prev: *mut monad_async_io_status,
    pub next: *mut monad_async_io_status,
    pub cancel_: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: monad_async_task,
            arg2: *mut monad_async_io_status,
        ) -> monad_async_result,
    >,
    #[doc = "! Unspecified value immediately after initiating call returns. Will become"]
    #[doc = "! bytes transferred if operation is successful, or another error if it"]
    #[doc = "! fails or is cancelled."]
    pub result: monad_async_result,
    pub ticks_when_initiated: monad_async_cpu_ticks_count_t,
    pub ticks_when_completed: monad_async_cpu_ticks_count_t,
    pub ticks_when_reaped: monad_async_cpu_ticks_count_t,
}
impl Default for monad_async_io_status {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "! \\brief The public attributes of a task"]
#[repr(C)]
#[derive(Debug)]
pub struct monad_async_task_head {
    pub user_code: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut monad_async_task_head) -> monad_async_result,
    >,
    pub user_ptr: *mut ::std::os::raw::c_void,
    pub priority: monad_async_task_head__bindgen_ty_1,
    pub result: monad_async_result,
    pub current_executor: u64,
    pub is_awaiting_dispatch: atomic_bool,
    pub is_pending_launch: atomic_bool,
    pub is_running: atomic_bool,
    pub is_suspended_sqe_exhaustion: atomic_bool,
    pub is_suspended_sqe_exhaustion_wr: atomic_bool,
    pub is_suspended_awaiting: atomic_bool,
    pub is_suspended_completed: atomic_bool,
    pub is_running_on_foreign_executor: atomic_bool,
    pub pending_launch_queue_: monad_async_priority,
    pub ticks_when_submitted: monad_async_cpu_ticks_count_t,
    pub ticks_when_attached: monad_async_cpu_ticks_count_t,
    pub ticks_when_detached: monad_async_cpu_ticks_count_t,
    pub ticks_when_suspended_awaiting: monad_async_cpu_ticks_count_t,
    pub ticks_when_suspended_completed: monad_async_cpu_ticks_count_t,
    pub ticks_when_resumed: monad_async_cpu_ticks_count_t,
    pub total_ticks_executed: monad_async_cpu_ticks_count_t,
    pub io_submitted: size_t,
    pub io_completed_not_reaped: size_t,
}
#[repr(C)]
#[derive(Debug)]
pub struct monad_async_task_head__bindgen_ty_1 {
    pub cpu: monad_async_priority,
    pub io: monad_async_priority,
}
impl Default for monad_async_task_head__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for monad_async_task_head {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "! \\brief Attributes by which to construct a task"]
#[repr(C)]
#[derive(Debug, Default)]
pub struct monad_async_task_attr {
    #[doc = "! \\brief 0 chooses platform default stack size"]
    pub stack_size: size_t,
}
extern "C" {
    #[doc = "! \\brief EXPENSIVE Creates a task instance using the specified context"]
    #[doc = "! switcher."]
    pub fn monad_async_task_create(
        task: *mut monad_async_task,
        switcher: monad_async_context_switcher,
        attr: *mut monad_async_task_attr,
    ) -> monad_async_result;
}
extern "C" {
    #[doc = "! \\brief EXPENSIVE Destroys a task instance. If the task is currently"]
    #[doc = "! suspended, it will be cancelled first in which case `EAGAIN` may be returned"]
    #[doc = "! from this function until cancellation succeeds."]
    pub fn monad_async_task_destroy(task: monad_async_task) -> monad_async_result;
}
extern "C" {
    #[doc = "! \\brief THREADSAFE Attaches a task instance onto a given executor, which"]
    #[doc = "! means it will launch the next time the executor runs. If the task is"]
    #[doc = "! attached already to a different executor, you MUST call this function from"]
    #[doc = "! that executor's kernel thread. If you optionally choose to reparent the"]
    #[doc = "! task's context to a new context switcher instance (typical if attaching"]
    #[doc = "! to an executor on a different kernel thread), it MUST be the same type of"]
    #[doc = "! context switcher."]
    pub fn monad_async_task_attach(
        executor: monad_async_executor,
        task: monad_async_task,
        opt_reparent_switcher: monad_async_context_switcher,
    ) -> monad_async_result;
}
extern "C" {
    #[doc = "! \\brief THREADSAFE If a task is currently suspended on an operation, cancel"]
    #[doc = "! it. This can take some time for the relevant io_uring operation to also"]
    #[doc = "! cancel. If the task is yet to launch, don't launch it. If the task isn't"]
    #[doc = "! currently running, returns `ENOENT`. The suspension point will return"]
    #[doc = "! `ECANCELED` next time the task resumes."]
    pub fn monad_async_task_cancel(
        executor: monad_async_executor,
        task: monad_async_task,
    ) -> monad_async_result;
}
extern "C" {
    #[doc = "! \\brief Change the CPU or i/o priority of a task"]
    pub fn monad_async_task_set_priorities(
        task: monad_async_task,
        cpu: monad_async_priority,
        io: monad_async_priority,
    ) -> monad_async_result;
}
extern "C" {
    #[doc = "! \\brief Ask io_uring to cancel a previously initiated operation. It can take"]
    #[doc = "! some time for io_uring to cancel an operation, and it may ignore your"]
    #[doc = "! request."]
    pub fn monad_async_task_io_cancel(
        task: monad_async_task,
        iostatus: *mut monad_async_io_status,
    ) -> monad_async_result;
}
extern "C" {
    #[doc = "! \\brief Iterate through completed i/o for this task, reaping each from the"]
    #[doc = "! completed but not repeated list."]
    pub fn monad_async_task_completed_io(task: monad_async_task) -> *mut monad_async_io_status;
}
extern "C" {
    #[doc = "! \\brief CANCELLATION POINT Suspend execution of a task for a given duration,"]
    #[doc = "! which can be zero (which equates \"yield\"). If `completed` is not null, if"]
    #[doc = "! any i/o which the task has initiated completes during the suspension, resume"]
    #[doc = "! the task setting `completed` to which i/o has just completed."]
    pub fn monad_async_task_suspend_for_duration(
        completed: *mut *mut monad_async_io_status,
        task: monad_async_task,
        ns: u64,
    ) -> monad_async_result;
}
extern "C" {
    #[doc = "! \\brief Retrieve the original `monad_async_task` from a fiber task structure"]
    #[doc = "! previously returned by `monad_fiber_task_from_async_task`."]
    pub fn monad_async_task_from_fiber_task(task: *mut monad_fiber_task) -> monad_async_task;
}
#[doc = "! \\brief The public attributes of an executor"]
#[repr(C)]
#[derive(Debug, Default)]
pub struct monad_async_executor_head {
    pub current_task: u64,
    pub tasks_pending_launch: atomic_size_t,
    pub tasks_running: atomic_size_t,
    pub tasks_suspended_sqe_exhaustion: atomic_size_t,
    pub tasks_suspended: atomic_size_t,
    pub total_ticks_in_run: monad_async_cpu_ticks_count_t,
    pub total_ticks_in_task_launch: monad_async_cpu_ticks_count_t,
    pub total_ticks_in_io_uring: monad_async_cpu_ticks_count_t,
    pub total_ticks_sleeping: monad_async_cpu_ticks_count_t,
    pub total_ticks_in_task_completion: monad_async_cpu_ticks_count_t,
}
#[doc = "! \\brief Attributes by which to construct an executor"]
#[repr(C)]
#[derive(Debug, Default)]
pub struct monad_async_executor_attr {
    pub io_uring_ring: monad_async_executor_attr__bindgen_ty_1,
    pub io_uring_wr_ring: monad_async_executor_attr__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct monad_async_executor_attr__bindgen_ty_1 {
    #[doc = "! \\brief If this is zero, this executor will be incapable of doing"]
    #[doc = "! i/o! It also no longer initialises io_uring for this executor."]
    pub entries: ::std::os::raw::c_uint,
    pub params: io_uring_params,
    pub registered_buffers: monad_async_executor_attr__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct monad_async_executor_attr__bindgen_ty_1__bindgen_ty_1 {
    #[doc = "! \\brief How many small and large buffers to register."]
    pub small: ::std::os::raw::c_uint,
    #[doc = "! \\brief How many small and large buffers to register."]
    pub large: ::std::os::raw::c_uint,
}
#[doc = "! \\brief A registered i/o buffer"]
#[repr(C)]
#[derive(Debug)]
pub struct monad_async_executor_registered_io_buffer {
    pub index: ::std::os::raw::c_int,
    pub iov: [iovec; 1usize],
}
impl Default for monad_async_executor_registered_io_buffer {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " \\brief EXPENSIVE Creates an executor instance. You must create it on the"]
    #[doc = "kernel thread where it will be used."]
    #[doc = ""]
    #[doc = "Generally, one also needs to create context switcher instances for each"]
    #[doc = "executor instance. This is because the context switcher needs to store how"]
    #[doc = "to resume the executor when a task's execution suspends."]
    pub fn monad_async_executor_create(
        ex: *mut monad_async_executor,
        attr: *mut monad_async_executor_attr,
    ) -> monad_async_result;
}
extern "C" {
    #[doc = "! \\brief EXPENSIVE Destroys an executor instance."]
    pub fn monad_async_executor_destroy(ex: monad_async_executor) -> monad_async_result;
}
extern "C" {
    #[doc = " \\brief Processes no more than `max_items` work items, returning the number"]
    #[doc = "of items processed. A null `timeout` means wait forever, and a zero timeout will"]
    #[doc = "poll without blocking."]
    #[doc = ""]
    #[doc = "Note that this function is particularly prone to early return i.e. partly"]
    #[doc = "or entirely ignoring timeout. Causes can include being woken externally by"]
    #[doc = "`monad_async_executor_wake()`, there being write i/o pending (as then two"]
    #[doc = "rings need to be checked), and the usual spurious early timeouts from Linux."]
    #[doc = "If you do complex processing around calling this function, it may be wise"]
    #[doc = "to only do that processing if the value returned is not zero."]
    pub fn monad_async_executor_run(
        ex: monad_async_executor,
        max_items: size_t,
        timeout: *mut timespec,
    ) -> monad_async_result;
}
extern "C" {
    #[doc = "! \\brief THREADSAFE Causes a sleeping executor to wake. Can be called from any"]
    #[doc = "! kernel thread. `cause_run_to_return` causes `monad_async_executor_run()` to"]
    #[doc = "! return the result given, otherwise the internal sleep wakes, executor state"]
    #[doc = "! is examined for new work and the sleep reestablished."]
    pub fn monad_async_executor_wake(
        ex: monad_async_executor,
        cause_run_to_return: *const monad_async_result,
    ) -> monad_async_result;
}
extern "C" {
    #[doc = " \\brief Claim an unused registered buffer, if there is one."]
    #[doc = ""]
    #[doc = "There are two sizes of registered i/o buffer, small and large which are the page"]
    #[doc = "size of the host platform (e.g. 4Kb and 2Mb if on Intel x64). Through being a"]
    #[doc = "single page size, DMA using registered i/o buffers has the lowest possible"]
    #[doc = "overhead."]
    pub fn monad_async_executor_claim_registered_io_buffer(
        buffer: *mut monad_async_executor_registered_io_buffer,
        ex: monad_async_executor,
        bytes_requested: size_t,
        is_for_write: bool,
    ) -> monad_async_result;
}
extern "C" {
    #[doc = "! \\brief Release a previously claimed registered buffer."]
    pub fn monad_async_executor_release_registered_io_buffer(
        ex: monad_async_executor,
        buffer_index: ::std::os::raw::c_int,
    ) -> monad_async_result;
}
#[doc = "! \\brief An offset into a file"]
pub type monad_async_file_offset = u64;
#[doc = "! \\brief The public attributes of an open file"]
#[repr(C)]
#[derive(Debug)]
pub struct monad_async_file_head {
    pub executor: monad_async_executor,
}
impl Default for monad_async_file_head {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "! \\brief The public attributes of an open file"]
pub type monad_async_file = *mut monad_async_file_head;
extern "C" {
    #[doc = " \\brief EXPENSIVE, CANCELLATION POINT Suspend execution of the task until the"]
    #[doc = "file has been opened. See `man open2` to explain parameters."]
    #[doc = ""]
    #[doc = "This is a relatively expensive operation as it may do up to two mallocs and"]
    #[doc = "several syscalls per call."]
    pub fn monad_async_task_file_create(
        file: *mut monad_async_file,
        task: monad_async_task,
        base: monad_async_file,
        subpath: *const ::std::os::raw::c_char,
        how: *mut open_how,
    ) -> monad_async_result;
}
extern "C" {
    #[doc = "! \\brief Suspend execution of the task until the file has been closed"]
    pub fn monad_async_task_file_destroy(
        task: monad_async_task,
        file: monad_async_file,
    ) -> monad_async_result;
}
extern "C" {
    #[doc = "! \\brief CANCELLATION POINT Suspend execution of the task until the file's"]
    #[doc = "! valid extents have been modified as per the `fallocate` call, see `man"]
    #[doc = "! fallocate` for more."]
    pub fn monad_async_task_file_fallocate(
        task: monad_async_task,
        file: monad_async_file,
        mode: ::std::os::raw::c_int,
        offset: monad_async_file_offset,
        len: monad_async_file_offset,
    ) -> monad_async_result;
}
extern "C" {
    #[doc = " \\brief Initiate a read from an open file using `iostatus` as the identifier."]
    #[doc = ""]
    #[doc = "Returns immediately unless there are no free io_uring submission entries."]
    #[doc = "See `man readv2` to explain parameters. The i/o priority used will be that"]
    #[doc = "from the task's current i/o priority setting."]
    #[doc = ""]
    #[doc = "\\warning io_uring **requires** that the contents of iovecs have lifetime until"]
    #[doc = "the read completes. The only exception here is if `nr_vecs` is one."]
    pub fn monad_async_task_file_read(
        iostatus: *mut monad_async_io_status,
        task: monad_async_task,
        file: monad_async_file,
        buffer_index: ::std::os::raw::c_int,
        iovecs: *const iovec,
        nr_vecs: ::std::os::raw::c_uint,
        offset: monad_async_file_offset,
        flags: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " \\brief Initiate a write to an open file using `iostatus` as the identifier."]
    #[doc = ""]
    #[doc = "Returns immediately unless there are no free io_uring submission entries."]
    #[doc = "See `man writev2` to explain parameters. The i/o priority used will be that"]
    #[doc = "from the task's current i/o priority setting."]
    #[doc = ""]
    #[doc = "\\warning io_uring **requires** that the contents of iovecs have lifetime until"]
    #[doc = "the writes completes. The only exception here is if `nr_vecs` is one."]
    pub fn monad_async_task_file_write(
        iostatus: *mut monad_async_io_status,
        task: monad_async_task,
        file: monad_async_file,
        buffer_index: ::std::os::raw::c_int,
        iovecs: *const iovec,
        nr_vecs: ::std::os::raw::c_uint,
        offset: monad_async_file_offset,
        flags: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = "! \\brief Initiate a flush of dirty file extents using `iostatus` as the"]
    #[doc = "! identifier. Returns immediately unless there are no free io_uring submission"]
    #[doc = "! entries. See `man sync_file_range` to explain parameters. The i/o priority"]
    #[doc = "! used will be that from the task's current i/o priority setting. This is the"]
    #[doc = "! right call to use to encourage the kernel to flush a region of data now, it"]
    #[doc = "! is the wrong call to ensure write durability as it neither flushes metadata"]
    #[doc = "! nor tells the storage device to flush."]
    pub fn monad_async_task_file_range_sync(
        iostatus: *mut monad_async_io_status,
        task: monad_async_task,
        file: monad_async_file,
        offset: monad_async_file_offset,
        bytes: ::std::os::raw::c_uint,
        flags: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = "! \\brief Initiate a durable sync of an open file using `iostatus` as"]
    #[doc = "! the identifier. Returns immediately unless there are no free io_uring"]
    #[doc = "! submission entries. The i/o priority used will be that from the task's"]
    #[doc = "! current i/o priority setting. This is the right call to use to ensure"]
    #[doc = "! written data is durably placed onto non-volatile storage."]
    #[doc = "!"]
    #[doc = "! Note that this operation generally takes milliseconds to complete."]
    pub fn monad_async_task_file_durable_sync(
        iostatus: *mut monad_async_io_status,
        task: monad_async_task,
        file: monad_async_file,
    );
}
#[doc = "! \\brief The public attributes of an open socket"]
#[repr(C)]
#[derive(Debug)]
pub struct monad_async_socket_head {
    pub executor: monad_async_executor,
}
impl Default for monad_async_socket_head {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "! \\brief The public attributes of an open socket"]
pub type monad_async_socket = *mut monad_async_socket_head;
extern "C" {
    #[doc = " \\brief EXPENSIVE, CANCELLATION POINT Suspend execution of the task until the"]
    #[doc = "socket has been opened. See `man socket` to explain parameters."]
    #[doc = ""]
    #[doc = "This is a relatively expensive operation as it may do up to two mallocs and"]
    #[doc = "several syscalls per call."]
    pub fn monad_async_task_socket_create(
        sock: *mut monad_async_socket,
        task: monad_async_task,
        domain: ::std::os::raw::c_int,
        type_: ::std::os::raw::c_int,
        protocol: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_uint,
    ) -> monad_async_result;
}
extern "C" {
    #[doc = "! \\brief Suspend execution of the task until the socket has been closed"]
    pub fn monad_async_task_socket_destroy(
        task: monad_async_task,
        file: monad_async_socket,
    ) -> monad_async_result;
}
extern "C" {
    #[doc = " \\brief CANCELLATION POINT Suspend execution of the task if there is no"]
    #[doc = "pending connection on the socket until there is a new connection. See `man"]
    #[doc = "accept4` to explain parameters."]
    pub fn monad_async_task_socket_accept(
        task: monad_async_task,
        sock: monad_async_socket,
        addr: *mut sockaddr,
        addrlen: *mut socklen_t,
        flags: ::std::os::raw::c_int,
    ) -> monad_async_result;
}
extern "C" {
    #[doc = " \\brief Initiate a connect of an open socket using `iostatus` as the"]
    #[doc = "identifier."]
    #[doc = ""]
    #[doc = "Returns immediately unless there are no free io_uring submission entries."]
    #[doc = "See `man sendmsg` to explain parameters. The i/o priority used will be that"]
    #[doc = "from the task's current i/o priority setting."]
    #[doc = ""]
    #[doc = "\\warning io_uring **requires** that the contents of `addr` has lifetime until"]
    #[doc = "the write completes."]
    pub fn monad_async_task_socket_connect(
        iostatus: *mut monad_async_io_status,
        task: monad_async_task,
        sock: monad_async_socket,
        addr: *mut sockaddr,
        addrlen: socklen_t,
    );
}
extern "C" {
    #[doc = " \\brief Initiate a shutdown of an open socket using `iostatus` as the"]
    #[doc = "identifier."]
    #[doc = ""]
    #[doc = "Returns immediately unless there are no free io_uring submission entries."]
    #[doc = "See `man shutdown` to explain parameters. The i/o priority used will be that"]
    #[doc = "from the task's current i/o priority setting."]
    pub fn monad_async_task_socket_shutdown(
        iostatus: *mut monad_async_io_status,
        task: monad_async_task,
        sock: monad_async_socket,
        how: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " \\brief Initiate a read from an open socket using `iostatus` as the"]
    #[doc = "identifier."]
    #[doc = ""]
    #[doc = "Returns immediately unless there are no free io_uring submission entries."]
    #[doc = "See `man recvmsg` to explain parameters. The i/o priority used will be that"]
    #[doc = "from the task's current i/o priority setting."]
    #[doc = ""]
    #[doc = "\\warning io_uring **requires** that the contents of `msg` and everything it"]
    #[doc = "points at have lifetime until the read completes."]
    pub fn monad_async_task_socket_recv(
        iostatus: *mut monad_async_io_status,
        task: monad_async_task,
        sock: monad_async_socket,
        buffer_index: ::std::os::raw::c_int,
        msg: *mut msghdr,
        flags: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " \\brief Initiate a write to an open socket using `iostatus` as the"]
    #[doc = "identifier."]
    #[doc = ""]
    #[doc = "Returns immediately unless there are no free io_uring submission entries."]
    #[doc = "See `man sendmsg` to explain parameters. The i/o priority used will be that"]
    #[doc = "from the task's current i/o priority setting."]
    #[doc = ""]
    #[doc = "\\warning io_uring **requires** that the contents of `msg` and everything it"]
    #[doc = "points at have lifetime until the write completes."]
    pub fn monad_async_task_socket_send(
        iostatus: *mut monad_async_io_status,
        task: monad_async_task,
        sock: monad_async_socket,
        buffer_index: ::std::os::raw::c_int,
        msg: *const msghdr,
        flags: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = "! \\brief Returns a temporary directory in which `O_DIRECT` files definitely"]
    #[doc = "! work"]
    pub fn monad_async_working_temporary_directory() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "! \\brief Creates a temporary file, writing the path created into the buffer."]
    #[doc = "! You will need to unlink this after yourself and close the file descriptor it"]
    #[doc = "! returns."]
    pub fn monad_async_make_temporary_file(
        buffer: *mut ::std::os::raw::c_char,
        buffer_len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "! \\brief Creates already deleted file so no need to clean it up"]
    #[doc = "! after. You will need to close the file descriptor it returns."]
    pub fn monad_async_make_temporary_inode() -> ::std::os::raw::c_int;
}
#[doc = "! \\brief The public attributes of a work dispatcher"]
#[repr(C)]
#[derive(Debug, Default)]
pub struct monad_async_work_dispatcher_head {
    pub executors: monad_async_work_dispatcher_head__bindgen_ty_1,
    pub tasks_awaiting_dispatch: atomic_size_t,
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct monad_async_work_dispatcher_head__bindgen_ty_1 {
    pub working: atomic_uint,
    pub idle: atomic_uint,
}
#[doc = "! \\brief The public attributes of a work dispatcher"]
pub type monad_async_work_dispatcher = *mut monad_async_work_dispatcher_head;
#[doc = "! \\brief The public attributes of a work dispatcher"]
#[repr(C)]
#[derive(Debug)]
pub struct monad_async_work_dispatcher_executor_head {
    pub derived: *mut monad_async_executor_head,
    pub dispatcher: monad_async_work_dispatcher,
    pub is_working: atomic_bool,
    pub is_idle: atomic_bool,
}
impl Default for monad_async_work_dispatcher_executor_head {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "! \\brief The public attributes of a work dispatcher"]
pub type monad_async_work_dispatcher_executor = *mut monad_async_work_dispatcher_executor_head;
#[doc = "! \\brief Attributes by which to construct a work dispatcher"]
#[repr(C)]
#[derive(Debug, Default)]
pub struct monad_async_work_dispatcher_attr {
    #[doc = "! Dispatcher executors should spin the CPU for this many milliseconds"]
    #[doc = "! before sleeping"]
    pub spin_before_sleep_ms: u32,
}
#[doc = "! \\brief Attributes by which to construct a work dispatcher"]
#[repr(C)]
#[derive(Debug, Default)]
pub struct monad_async_work_dispatcher_executor_attr {
    pub derived: monad_async_executor_attr,
}
extern "C" {
    #[doc = "! \\brief EXPENSIVE Creates a work dispatcher instance."]
    pub fn monad_async_work_dispatcher_create(
        dp: *mut monad_async_work_dispatcher,
        attr: *mut monad_async_work_dispatcher_attr,
    ) -> monad_async_result;
}
extern "C" {
    #[doc = "! \\brief EXPENSIVE Destroys a work dispatcher instance."]
    pub fn monad_async_work_dispatcher_destroy(
        dp: monad_async_work_dispatcher,
    ) -> monad_async_result;
}
extern "C" {
    #[doc = "! \\brief EXPENSIVE Creates a work dispatcher executor instance."]
    pub fn monad_async_work_dispatcher_executor_create(
        ex: *mut monad_async_work_dispatcher_executor,
        dp: monad_async_work_dispatcher,
        attr: *mut monad_async_work_dispatcher_executor_attr,
    ) -> monad_async_result;
}
extern "C" {
    #[doc = "! \\brief EXPENSIVE Destroys a work dispatcher executor instance."]
    pub fn monad_async_work_dispatcher_executor_destroy(
        ex: monad_async_work_dispatcher_executor,
    ) -> monad_async_result;
}
extern "C" {
    #[doc = "! \\brief Calls `monad_async_executor_run()` for the calling kernel thread,"]
    #[doc = "! attaching tasks recently submitted to kernel threads in the pool with spare"]
    #[doc = "! capacity as per the work dispatcher's configured policy. Returns the number"]
    #[doc = "! of work items executed, or -1 when time to exit."]
    pub fn monad_async_work_dispatcher_executor_run(
        ex: monad_async_work_dispatcher_executor,
    ) -> monad_async_result;
}
extern "C" {
    #[doc = "! \\brief THREADSAFE Causes a sleeping work dispatcher executor to wake. Same"]
    #[doc = "! as `monad_async_executor_wake()`, but for work dispatcher executors."]
    pub fn monad_async_work_dispatcher_executor_wake(
        ex: monad_async_work_dispatcher_executor,
        cause_run_to_return: *const monad_async_result,
    ) -> monad_async_result;
}
extern "C" {
    #[doc = "! \\brief THREADSAFE Submits one or more tasks to be executed by the first"]
    #[doc = "! available executor within the work dispatcher pool. Higher priority tasks"]
    #[doc = "! are executed before lower priority tasks."]
    pub fn monad_async_work_dispatcher_submit(
        dp: monad_async_work_dispatcher,
        tasks: *mut monad_async_task,
        count: size_t,
    ) -> monad_async_result;
}
extern "C" {
    #[doc = "! \\brief THREADSAFE Wait until all work has been dispatched or executed."]
    pub fn monad_async_work_dispatcher_wait(
        dp: monad_async_work_dispatcher,
        max_undispatched: size_t,
        max_unexecuted: size_t,
        timeout: *mut timespec,
    ) -> monad_async_result;
}
extern "C" {
    #[doc = "! \\brief THREADSAFE Tells executors to quit, preferring idle executors first,"]
    #[doc = "! until no more than `max_executors` remains."]
    pub fn monad_async_work_dispatcher_quit(
        dp: monad_async_work_dispatcher,
        max_executors: size_t,
        timeout: *mut timespec,
    ) -> monad_async_result;
}
