/* automatically generated by rust-bindgen 0.59.1 */

#[repr(C)]
pub struct __BindgenUnionField<T>(::std::marker::PhantomData<T>);
impl<T> __BindgenUnionField<T> {
    #[inline]
    pub const fn new() -> Self {
        __BindgenUnionField(::std::marker::PhantomData)
    }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T {
        ::std::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T {
        ::std::mem::transmute(self)
    }
}
impl<T> ::std::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self {
        Self::new()
    }
}
impl<T> ::std::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self {
        Self::new()
    }
}
impl<T> ::std::marker::Copy for __BindgenUnionField<T> {}
impl<T> ::std::fmt::Debug for __BindgenUnionField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.write_str("__BindgenUnionField")
    }
}
impl<T> ::std::hash::Hash for __BindgenUnionField<T> {
    fn hash<H: ::std::hash::Hasher>(&self, _state: &mut H) {}
}
impl<T> ::std::cmp::PartialEq for __BindgenUnionField<T> {
    fn eq(&self, _other: &__BindgenUnionField<T>) -> bool {
        true
    }
}
impl<T> ::std::cmp::Eq for __BindgenUnionField<T> {}
pub type size_t = ::std::os::raw::c_ulong;
pub type fcontext_t = *mut ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug)]
pub struct monad_fiber_context {
    pub fiber: fcontext_t,
    pub name: *const ::std::os::raw::c_char,
}
impl Default for monad_fiber_context {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type monad_fiber_context_t = monad_fiber_context;
extern "C" {
    pub fn monad_fiber_main_context() -> *mut monad_fiber_context_t;
}
extern "C" {
    pub fn monad_fiber_set_name(
        arg1: *mut monad_fiber_context_t,
        name: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn monad_fiber_context_switch(
        from: *mut monad_fiber_context_t,
        to: *mut monad_fiber_context_t,
    ) -> *mut monad_fiber_context_t;
}
extern "C" {
    pub fn monad_fiber_context_switch_with(
        from: *mut monad_fiber_context_t,
        to: *mut monad_fiber_context_t,
        func: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut monad_fiber_context_t,
                arg2: *mut ::std::os::raw::c_void,
            ) -> *mut monad_fiber_context_t,
        >,
        arg: *mut ::std::os::raw::c_void,
    ) -> *mut monad_fiber_context_t;
}
pub const monad_fiber_default_stack_size: size_t = 131072;
extern "C" {
    pub fn monad_fiber_context_callcc(
        from: *mut monad_fiber_context_t,
        stack_size: size_t,
        protected_stack: bool,
        func: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *mut monad_fiber_context_t,
                arg3: *mut monad_fiber_context_t,
            ) -> *mut monad_fiber_context_t,
        >,
        func_arg: *mut ::std::os::raw::c_void,
    ) -> *mut monad_fiber_context_t;
}
pub type __int64_t = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Default)]
pub struct monad_fiber_task {
    pub resume: ::std::option::Option<unsafe extern "C" fn(arg1: *mut monad_fiber_task)>,
    pub destroy: ::std::option::Option<unsafe extern "C" fn(arg1: *mut monad_fiber_task)>,
}
pub type monad_fiber_task_t = monad_fiber_task;
#[repr(C)]
#[derive(Debug)]
pub struct monad_fiber_task_node {
    pub task: *mut monad_fiber_task_t,
    pub priority: i64,
}
impl Default for monad_fiber_task_node {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct monad_fiber_task_queue {
    pub memory: *mut monad_fiber_task_node,
    pub capacity: size_t,
    pub data: *mut monad_fiber_task_node,
    pub size: size_t,
}
impl Default for monad_fiber_task_queue {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type monad_fiber_task_queue_t = monad_fiber_task_queue;
extern "C" {
    pub fn monad_fiber_task_queue_init(arg1: *mut monad_fiber_task_queue);
}
extern "C" {
    pub fn monad_fiber_task_queue_destroy(arg1: *mut monad_fiber_task_queue);
}
extern "C" {
    pub fn monad_fiber_task_queue_grow(arg1: *mut monad_fiber_task_queue);
}
extern "C" {
    pub fn monad_fiber_task_queue_pop_front(
        arg1: *mut monad_fiber_task_queue,
    ) -> monad_fiber_task_node;
}
extern "C" {
    pub fn monad_fiber_task_queue_insert(
        arg1: *mut monad_fiber_task_queue,
        task: *mut monad_fiber_task_t,
        priority: i64,
    );
}
pub type atomic_int = u32;
#[repr(C)]
pub struct __atomic_wide_counter {
    pub __value64: __BindgenUnionField<::std::os::raw::c_ulonglong>,
    pub __value32: __BindgenUnionField<__atomic_wide_counter__bindgen_ty_1>,
    pub bindgen_union_field: u64,
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct __atomic_wide_counter__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
impl Default for __atomic_wide_counter {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
impl Default for __pthread_internal_list {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
#[derive(Debug)]
pub struct __pthread_mutex_s {
    pub __lock: ::std::os::raw::c_int,
    pub __count: ::std::os::raw::c_uint,
    pub __owner: ::std::os::raw::c_int,
    pub __nusers: ::std::os::raw::c_uint,
    pub __kind: ::std::os::raw::c_int,
    pub __spins: ::std::os::raw::c_short,
    pub __elision: ::std::os::raw::c_short,
    pub __list: __pthread_list_t,
}
impl Default for __pthread_mutex_s {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct __pthread_cond_s {
    pub __wseq: __atomic_wide_counter,
    pub __g1_start: __atomic_wide_counter,
    pub __g_refs: [::std::os::raw::c_uint; 2usize],
    pub __g_size: [::std::os::raw::c_uint; 2usize],
    pub __g1_orig_size: ::std::os::raw::c_uint,
    pub __wrefs: ::std::os::raw::c_uint,
    pub __g_signals: [::std::os::raw::c_uint; 2usize],
}
impl Default for __pthread_cond_s {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type pthread_t = ::std::os::raw::c_ulong;
#[repr(C)]
pub struct pthread_mutex_t {
    pub __data: __BindgenUnionField<__pthread_mutex_s>,
    pub __size: __BindgenUnionField<[::std::os::raw::c_char; 40usize]>,
    pub __align: __BindgenUnionField<::std::os::raw::c_long>,
    pub bindgen_union_field: [u64; 5usize],
}
impl Default for pthread_mutex_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct pthread_cond_t {
    pub __data: __BindgenUnionField<__pthread_cond_s>,
    pub __size: __BindgenUnionField<[::std::os::raw::c_char; 48usize]>,
    pub __align: __BindgenUnionField<::std::os::raw::c_longlong>,
    pub bindgen_union_field: [u64; 6usize],
}
impl Default for pthread_cond_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct monad_fiber_scheduler {
    pub threads: *mut pthread_t,
    pub thread_count: size_t,
    pub mutex: pthread_mutex_t,
    pub cond: pthread_cond_t,
    pub task_queue: monad_fiber_task_queue_t,
    pub thread_id_source: atomic_int,
}
impl Default for monad_fiber_scheduler {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type monad_fiber_scheduler_t = monad_fiber_scheduler;
extern "C" {
    pub fn monad_fiber_scheduler_current() -> *mut monad_fiber_scheduler_t;
}
extern "C" {
    pub fn monad_fiber_scheduler_work(arg1: *mut monad_fiber_scheduler_t);
}
extern "C" {
    pub fn monad_fiber_scheduler_create(arg1: *mut monad_fiber_scheduler_t, threads: size_t);
}
extern "C" {
    pub fn monad_fiber_scheduler_destroy(arg1: *mut monad_fiber_scheduler_t);
}
extern "C" {
    pub fn monad_fiber_scheduler_stop(arg1: *mut monad_fiber_scheduler_t);
}
extern "C" {
    pub fn monad_fiber_scheduler_post(
        arg1: *mut monad_fiber_scheduler_t,
        task: *mut monad_fiber_task_t,
        priority: i64,
    );
}
extern "C" {
    pub fn monad_fiber_scheduler_dispatch(
        arg1: *mut monad_fiber_scheduler_t,
        task: *mut monad_fiber_task_t,
        priority: i64,
    );
}
extern "C" {
    pub fn monad_fiber_scheduler_pop_higher_priority_task(
        arg1: *mut monad_fiber_scheduler_t,
        priority: i64,
    ) -> *mut monad_fiber_task_t;
}
extern "C" {
    pub fn monad_fiber_run_one(arg1: *mut monad_fiber_scheduler_t) -> bool;
}
#[repr(C)]
#[derive(Debug)]
pub struct monad_fiber {
    pub task: monad_fiber_task_t,
    pub context: *mut monad_fiber_context_t,
    pub priority: i64,
    pub scheduler: *mut monad_fiber_scheduler_t,
}
impl Default for monad_fiber {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type monad_fiber_t = monad_fiber;
extern "C" {
    pub fn monad_fiber_current() -> *mut monad_fiber_t;
}
extern "C" {
    pub fn monad_fiber_is_main(arg1: *mut monad_fiber_t) -> bool;
}
extern "C" {
    pub fn monad_fiber_switch_to_fiber(arg1: *mut monad_fiber_t);
}
extern "C" {
    pub fn monad_fiber_switch_to_main();
}
extern "C" {
    pub fn monad_fiber_init_main();
}
extern "C" {
    pub fn monad_fiber_yield();
}
extern "C" {
    pub fn monad_fiber_yield_to(target: *mut monad_fiber_context_t);
}
extern "C" {
    pub fn monad_fiber_activate_fiber(new_current: *mut monad_fiber_t) -> *mut monad_fiber_t;
}
extern "C" {
    pub fn monad_fiber_main() -> *mut monad_fiber_t;
}
extern "C" {
    pub fn monad_fiber_await(
        suspend_to: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut monad_fiber_t, arg2: *mut ::std::os::raw::c_void),
        >,
        arg: *mut ::std::os::raw::c_void,
    );
}
#[repr(C)]
pub struct monad_fiber_channel {
    pub capacity: size_t,
    pub size: size_t,
    pub offset: size_t,
    pub element_size: size_t,
    pub data: *mut ::std::os::raw::c_void,
    pub mutex: pthread_mutex_t,
    pub pending_reads: *mut monad_fiber_channel_read_op,
    pub pending_writes: *mut monad_fiber_channel_write_op,
}
impl Default for monad_fiber_channel {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type monad_fiber_channel_t = monad_fiber_channel;
extern "C" {
    pub fn monad_fiber_channel_create(
        arg1: *mut monad_fiber_channel_t,
        capacity: size_t,
        element_size: size_t,
    );
}
extern "C" {
    pub fn monad_fiber_channel_destroy(arg1: *mut monad_fiber_channel_t);
}
extern "C" {
    pub fn monad_fiber_channel_try_read(
        arg1: *mut monad_fiber_channel_t,
        target: *mut ::std::os::raw::c_void,
    ) -> bool;
}
extern "C" {
    pub fn monad_fiber_channel_try_write(
        arg1: *mut monad_fiber_channel_t,
        source: *const ::std::os::raw::c_void,
    ) -> bool;
}
extern "C" {
    pub fn monad_fiber_channel_read(
        arg1: *mut monad_fiber_channel_t,
        target: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn monad_fiber_channel_write(
        arg1: *mut monad_fiber_channel_t,
        source: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct monad_fiber_channel_read_op {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct monad_fiber_channel_write_op {
    pub _address: u8,
}
